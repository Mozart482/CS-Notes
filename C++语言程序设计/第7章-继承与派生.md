# 1 类的继承与派生

## 继承与派生概述

* 继承与派生是同一过程从不同的角度看

  * 保持已有类的特性而构造新类的过程称为**继承**
  
  * 在已有类的基础上新增自己的特性而产生新类的过程称为**派生**

* 被继承的已有类称为**基类**（或父类）

* 派生出的新类称为**派生类**（或子类）

* 直接参与派生出某类的基类称为**直接基类**

* 基类的基类甚至更高层的基类称为**间接基类**

### 继承与派生的目的

* 继承的目的：实现设计与代码的重用

* 派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。

### 单继承时派生类的定义

* 语法
```
	class 派生类名：继承方式 基类名

	{

		成员声明；

	}
```

* 例：
```
	class Derived: public Base

	{

		public:

		Derived ();

		~Derived ();

	};
```

### 多继承时派生类的定义

* 语法
```
	class 派生类名：继承方式1 基类名1，继承方式2 基类名2，...

	{

		成员声明；

	}
```

*注意：每一个“继承方式”，只用于限制对紧随其后之基类的继承。

* 例
```
	class Derived: public Base1, private Base2

	{

		public:

		Derived ();

		~Derived ();

	};
```

## 继承方式

### 不同继承方式的影响主要体现在：

* 派生类成员对基类成员的访问权限

* 通过派生类对象对基类成员的访问权限

### 三种继承方式

* 公有继承

* 私有继承

* 保护继承

### 公有继承（public）

* 继承的访问控制

  * 基类的public和protected成员：访问属性在派生类中保持不变；

  * 基类的private成员：不可直接访问。

* 访问权限

  * 派生类中的成员函数：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员；

  * 通过派生类的对象：只能访问public成员。

**例7-1 公有继承举例**

Point.h
```
#ifndef _POINT_H
#define _POINT_H
class Point {   
    //基类Point类的定义
    public:     
    //公有函数成员
        void initPoint(float x = 0, float y = 0){ 
            this->x = x; 
            this->y = y;
        }
        void move(float offX, float offY){ 
            x += offX; 
            y += offY;
        }
        float getX() const { return x; }
        float getY() const { return y; }
    private:        
    //私有数据成员
        float x, y;
};
#endif //_POINT_H
```
Rectangle.h
```
#ifndef _RECTANGLE_H
#define _RECTANGLE_H
#include "Point.h"
class Rectangle: public Point { 
//派生类定义部分
public: 
//新增公有函数成员
    void initRectangle(float x, float y, float w, float h) {
        initPoint(x, y);              //调用基类公有成员函数
        this->w = w;
        this->h = h;
    }
    float getH() const { return h; }
    float getW() const { return w; }
private:    
//新增私有数据成员
    float w, h;
};
#endif //_RECTANGLE_H
```
main.cpp
```
#include <iostream>
#include <cmath>
using namespace std;
#include “Rectangle.h”
int main() {
    Rectangle rect; //定义Rectangle类的对象
    //设置矩形的数据
    rect.initRectangle(2, 3, 20, 10);   
    rect.move(3,2); //移动矩形位置
    cout << "The data of rect(x,y,w,h): " << endl;
    //输出矩形的特征参数
    cout << rect.getX() <<", "
        << rect.getY() << ", "
        << rect.getW() << ", "
        << rect.getH() << endl;
    return 0;
}
```

### 私有继承（private）

作用：将基类的原有接口都封闭掉

* 继承的访问控制

  * 基类的**public**和**protected成员：都以private**身份出现在派生类中；

  * 基类的private成员：**不可直接访问**。

* 访问权限

  * 派生类中的成员函数：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员；

  * 通过派生类的对象：不能直接访问从基类继承的任何成员。
  
**例7-2 私有继承举例**

Point.h
```
#ifndef _POINT_H
#define _POINT_H
class Point {   //基类Point类的定义
public: //公有函数成员
    void initPoint(float x = 0, float y = 0) 
    { this->x = x; this->y = y;}
    void move(float offX, float offY) 
    { x += offX; y += offY; }
    float getX() const { return x; }
    float getY() const { return y; }
private:    //私有数据成员
    float x, y;
};  
#endif //_POINT_H
```
Rectangle.h
```
#ifndef _RECTANGLE_H
#define _RECTANGLE_H
#include "Point.h"
class Rectangle: private Point {    //派生类定义部分
public: //新增公有函数成员
    void initRectangle(float x, float y, float w, float h) {
        initPoint(x, y); //调用基类公有成员函数
        this->w = w;
        this->h = h;
    }
    void move(float offX, float offY) {   Point::move(offX, offY);  }
    float getX() const { return Point::getX(); }
    float getY() const { return Point::getY(); }
    float getH() const { return h; }
    float getW() const { return w; }
private:    //新增私有数据成员
    float w, h;
};
#endif //_RECTANGLE_H
```
main.cpp
```
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    Rectangle rect; //定义Rectangle类的对象
    rect.initRectangle(2, 3, 20, 10);   //设置矩形的数据
    rect.move(3,2); //移动矩形位置
    cout << "The data of rect(x,y,w,h): " << endl;
    cout << rect.getX() <<", "  //输出矩形的特征参数
        << rect.getY() << ", "
        << rect.getW() << ", "
        << rect.getH() << endl;
    return 0;
}
```
### 保护继承(protected)

* 继承的访问控制

  * 基类的**public**和**protected成员：都以protected**身份出现在派生类中；

  * 基类的**private**成员：**不可直接访问**。

* 访问权限

  * 派生类中的成员函数：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员；

  * 通过派生类的对象：不能直接访问从基类继承的任何成员。

* protected 成员的特点与作用

  * 对建立其所在类对象的模块来说，它与 private 成员的性质相同。

  * 对于其派生类来说，它与 public 成员的性质相同。

  * 既实现了数据隐藏，又方便继承，实现代码重用。

  * 如果派生类有多个基类，也就是多继承时，可以用不同的方式继承每个基类。


**protected 成员举例（补7-1）**

```
class A {
protected:
    int x;
};

int main() {
    A a;
    a.x = 5;//错误
}
class A {
protected:
    int x;
};
class B: public A{
public:
    void function();
};
void B:function() {
    x = 5;   //正确
}
```
**多继承举例（补7-2）**
```
class A {
public:
    void setA(int);
    void showA() const;
private:
    int a;
};
class B {
public:
    void setB(int);
    void showB() const;
private:
    int b;
};
class C : public A, private B { 
public:
    void setC(int, int, int);
    void showC() const;
private:
    int c;
};
```
**多继承举例**
```
void  A::setA(int x) {
    a=x; 
}
void B::setB(int x) {
    b=x; 
}
void C::setC(int x, int y, int z) {
    //派生类成员直接访问基类的
    //公有成员
    setA(x); 
    setB(y); 
    c = z;
}

//其他函数实现略

int main() {
    C obj;
    obj.setA(5);
    obj.showA();
    obj.setC(6,7,9);
    obj.showC();
// obj.setB(6);  错误
// obj.showB(); 错误
    return 0;
}
```

## 基类与派生类类型转换

### 类型转换

* 公有派生类对象可以被当作基类的对象使用，反之则不可。

  * 派生类的对象可以隐含转换为基类对象；

  * 派生类的对象可以初始化基类的引用；

  * 派生类的指针可以隐含转换为基类的指针。

* 通过基类对象名、指针只能使用从基类继承的成员。

**例7-3 类型转换规则举例**
```
#include <iostream>
using namespace std;
class Base1 { //基类Base1定义
public:
    void display() const {
        cout << "Base1::display()" << endl;
    }
};
class Base2: public Base1 { //公有派生类Base2定义
public:
    void display() const {
        cout << "Base2::display()" << endl;
    }
};
class Derived: public Base2 { //公有派生类Derived定义
public:
    void display() const {
        cout << "Derived::display()" << endl;
    }
};
```

**例7-3 类型转换规则举例**

```
void fun(Base1 *ptr) {  //参数为指向基类对象的指针
    ptr->display();     //"对象指针->成员名"
}
int main() {    //主函数
    Base1 base1;    //声明Base1类对象
    Base2 base2;    //声明Base2类对象
    Derived derived;    //声明Derived类对象

    fun(&base1);    //用Base1对象的指针调用fun函数
    fun(&base2);    //用Base2对象的指针调用fun函数
    fun(&derived); //用Derived对象的指针调用fun函数

    return 0;
}
```

# 2 访问控制


# 3 类的兼容规则


# 4 派生类的构造和析构函数

# 5 派生类成员得标识与访问

