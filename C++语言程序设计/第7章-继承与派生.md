# 1 类的继承与派生

## 继承与派生概述

* 继承与派生是同一过程从不同的角度看

  * 保持已有类的特性而构造新类的过程称为**继承**
  
  * 在已有类的基础上新增自己的特性而产生新类的过程称为**派生**

* 被继承的已有类称为**基类**（或父类）

* 派生出的新类称为**派生类**（或子类）

* 直接参与派生出某类的基类称为**直接基类**

* 基类的基类甚至更高层的基类称为**间接基类**

### 继承与派生的目的

* 继承的目的：实现设计与代码的重用

* 派生的目的：当新的问题出现，原有程序无法解决（或不能完全解决）时，需要对原有程序进行改造。

### 单继承时派生类的定义

* 语法
```
class 派生类名：继承方式 基类名

{

	成员声明；

}
```

* 例：
```
class Derived: public Base

{

	public:

		Derived ();

		~Derived ();

};
```

### 多继承时派生类的定义

* 语法
```
class 派生类名：继承方式1 基类名1，继承方式2 基类名2，...

{

	成员声明；

}
```

*注意：每一个“继承方式”，只用于限制对紧随其后之基类的继承。

* 例
```
class Derived: public Base1, private Base2

{

	public:

		Derived ();

		~Derived ();

};
```

## 继承方式

### 不同继承方式的影响主要体现在：

* 派生类成员对基类成员的访问权限

* 通过派生类对象对基类成员的访问权限

### 三种继承方式

* 公有继承

* 私有继承

* 保护继承

### 公有继承（public）

* 继承的访问控制

  * 基类的public和protected成员：访问属性在派生类中保持不变；

  * 基类的private成员：不可直接访问。

* 访问权限

  * 派生类中的成员函数(派生类内部)：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员；

  * 通过派生类的对象(派生类之外)：只能访问public成员。

**例7-1 公有继承举例**

Point.h
```
#ifndef _POINT_H
#define _POINT_H
class Point {   
    //基类Point类的定义
    public:     
    //公有函数成员
        void initPoint(float x = 0, float y = 0){ 
            this->x = x; 
            this->y = y;
        }
        void move(float offX, float offY){ 
            x += offX; 
            y += offY;
        }
        float getX() const { return x; }
        float getY() const { return y; }
    private:        
    //私有数据成员
        float x, y;
};
#endif //_POINT_H
```
Rectangle.h
```
#ifndef _RECTANGLE_H
#define _RECTANGLE_H
#include "Point.h"
class Rectangle: public Point { 
//派生类定义部分
public: 
//新增公有函数成员
    void initRectangle(float x, float y, float w, float h) {
        initPoint(x, y);              //调用基类公有成员函数
        this->w = w;
        this->h = h;
    }
    float getH() const { return h; }
    float getW() const { return w; }
private:    
//新增私有数据成员
    float w, h;
};
#endif //_RECTANGLE_H
```
main.cpp
```
#include <iostream>
#include <cmath>
using namespace std;
#include “Rectangle.h”
int main() {
    Rectangle rect; //定义Rectangle类的对象
    //设置矩形的数据
    rect.initRectangle(2, 3, 20, 10);   
    rect.move(3,2); //移动矩形位置
    cout << "The data of rect(x,y,w,h): " << endl;
    //输出矩形的特征参数
    cout << rect.getX() <<", "
        << rect.getY() << ", "
        << rect.getW() << ", "
        << rect.getH() << endl;
    return 0;
}
```

### 私有继承（private）

作用：将基类的原有接口都封闭掉

* 继承的访问控制

  * 基类的**public**和**protected成员：都以private**身份出现在派生类中；

  * 基类的private成员：**不可直接访问**。

* 访问权限

  * 派生类中的成员函数（派生类内部）：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员；

  * 通过派生类的对象（派生类之外）：不能直接访问从基类继承的任何成员。
  
**例7-2 私有继承举例**

Point.h
```
#ifndef _POINT_H
#define _POINT_H
class Point {   //基类Point类的定义
public: //公有函数成员
    void initPoint(float x = 0, float y = 0) 
    { this->x = x; this->y = y;}
    void move(float offX, float offY) 
    { x += offX; y += offY; }
    float getX() const { return x; }
    float getY() const { return y; }
private:    //私有数据成员
    float x, y;
};  
#endif //_POINT_H
```
Rectangle.h
```
#ifndef _RECTANGLE_H
#define _RECTANGLE_H
#include "Point.h"
class Rectangle: private Point {    //派生类定义部分
public: //新增公有函数成员
    void initRectangle(float x, float y, float w, float h) {
        initPoint(x, y); //调用基类公有成员函数
        this->w = w;
        this->h = h;
    }
    void move(float offX, float offY) {   Point::move(offX, offY);  }
    float getX() const { return Point::getX(); }
    float getY() const { return Point::getY(); }
    float getH() const { return h; }
    float getW() const { return w; }
private:    //新增私有数据成员
    float w, h;
};
#endif //_RECTANGLE_H
```
main.cpp
```
#include <iostream>
#include <cmath>
using namespace std;

int main() {
    Rectangle rect; //定义Rectangle类的对象
    rect.initRectangle(2, 3, 20, 10);   //设置矩形的数据
    rect.move(3,2); //移动矩形位置
    cout << "The data of rect(x,y,w,h): " << endl;
    cout << rect.getX() <<", "  //输出矩形的特征参数
        << rect.getY() << ", "
        << rect.getW() << ", "
        << rect.getH() << endl;
    return 0;
}
```
### 保护继承(protected)

* 继承的访问控制

  * 基类的**public**和**protected成员：都以protected**身份出现在派生类中；

  * 基类的**private**成员：**不可直接访问**。

* 访问权限

  * 派生类中的成员函数：可以直接访问基类中的public和protected成员，但不能直接访问基类的private成员；

  * 通过派生类的对象：不能直接访问从基类继承的任何成员。

* protected 成员的特点与作用

  * 对建立其所在类对象的模块来说，它与 private 成员的性质相同。

  * 对于其派生类来说，它与 public 成员的性质相同。

  * 既实现了数据隐藏，又方便继承，实现代码重用。

  * 如果派生类有多个基类，也就是多继承时，可以用不同的方式继承每个基类。


**protected 成员举例（补7-1）**

```
class A {
protected:
    int x;
};

int main() {
    A a;
    a.x = 5;//错误
}
```
```
class A {
protected:
    int x;
};
class B: public A{
public:
    void function();
};
void B:function() {
    x = 5;   //正确
}
```
**多继承举例（补7-2）**
```
class A {
public:
    void setA(int);
    void showA() const;
private:
    int a;
};
class B {
public:
    void setB(int);
    void showB() const;
private:
    int b;
};
class C : public A, private B { 
public:
    void setC(int, int, int);
    void showC() const;
private:
    int c;
};
```
**多继承举例**
```
void  A::setA(int x) {
    a=x; 
}
void B::setB(int x) {
    b=x; 
}
void C::setC(int x, int y, int z) {
    //派生类成员直接访问基类的
    //公有成员
    setA(x); 
    setB(y); 
    c = z;
}

//其他函数实现略

int main() {
    C obj;
    obj.setA(5);
    obj.showA();
    obj.setC(6,7,9);
    obj.showC();
// obj.setB(6);  错误
// obj.showB(); 错误
    return 0;
}
```

## 基类与派生类类型转换

### 类型转换

* 公有派生类对象可以被当作基类的对象使用，反之则不可。(派生类比基类的东西多)

  * 派生类的对象可以隐含转换为基类对象；

  * 派生类的对象可以初始化基类的引用；

  * 派生类的指针可以隐含转换为基类的指针。

* 转换以后，通过基类对象名、指针只能使用从基类继承的成员。

**例7-3 类型转换规则举例**
```
#include <iostream>
using namespace std;
class Base1 { //基类Base1定义
public:
    void display() const {
        cout << "Base1::display()" << endl;
    }
};
class Base2: public Base1 { //公有派生类Base2定义
public:
    void display() const {
        cout << "Base2::display()" << endl;
    }
};
class Derived: public Base2 { //公有派生类Derived定义
public:
    void display() const {
        cout << "Derived::display()" << endl;
    }
};


void fun(Base1 *ptr) {  //参数为指向基类对象的指针
    ptr->display();     //"对象指针->成员名"
}
int main() {    //主函数
    Base1 base1;    //声明Base1类对象
    Base2 base2;    //声明Base2类对象
    Derived derived;    //声明Derived类对象

    fun(&base1);    //用Base1对象的指针调用fun函数
    fun(&base2);    //用Base2对象的指针调用fun函数
    fun(&derived); //用Derived对象的指针调用fun函数

    return 0;
}
```
运行结果：

```
Base1::display()
Base1::display()
Base1::display()
```

结论：

**不要重新定义继承而来的非虚函数！**

## 派生类的构造与析构

### 派生类的构造函数

* 默认情况下

  * 基类的构造函数不被继承;

  * 派生类需要定义自己的构造函数。
  
    * 派生类的构造函数需要向基类的初始化功能传递参数
	
    * 把从基类继承过来的成员初始化需要的参数传递给基类的构造函数
	
    * 派生类构造函数的函数体和初始化列表来完成本类新增成员的构造

* C++11规定

  * 派生类新增成员可以通过类内初始值进行初始化。

  * 可用using语句继承基类构造函数。

  * 但是只能初始化从基类继承的成员。

  * 语法形式：
    
	* using B::B;
  
**建议**

* 如果派生类有自己新增的成员，且需要通过构造函数参数指定的初始化，则派生类要自定义构造函数。

**若不继承基类的构造函数**

* 派生类新增成员：派生类定义构造函数初始化；

* 继承来的成员：自动调用基类构造函数进行初始化；

* 派生类的构造函数需要给基类的构造函数传递参数。

**单继承**

* 派生类只有一个直接基类的情况，是单继承。单继承时，派生类的构造函数只需要给一个直接基类构造函数传递参数。

**单继承时派生类构造函数的定义语法**
```
派生类名::派生类名(基类所需的形参，本类成员所需的形参):
基类名(参数表), 本类成员初始化列表
{
	//其他初始化；
}；
```

**单继承时的构造函数举例（补7-3）**
```
#include<iostream>
using namespace std;
class B {
public:
    B();
    B(int i);
    ~B();
    void print() const;
private:
    int b;
};

B::B() {
    b=0;
    cout << "B's default constructor called." << endl;
}
B::B(int i) {
    b=i;
    cout << "B's constructor called." << endl;
}
B::~B() {
    cout << "B's destructor called." << endl;
}
void B::print() const {
    cout << b << endl;
}

class C: public B {
public:
    C();
    C(int i, int j);
    ~C();
    void print() const;
private:
    int c;
};
C::C() {
    c = 0;
    cout << "C's default constructor called." << endl;
}
C::C(int i,int j): B(i), c(j){
    cout << "C's constructor called." << endl;
}

C::~C() {
    cout << "C's destructor called." << endl;
}
void C::print() const {
    B::print();
    cout << c << endl;
}

int main() {
    C obj(5, 6);
    obj.print();
    return 0;
}
```

**多继承**

* 多继承时，有多个直接基类，如果不继承基类的构造函数，派生类构造函数需要给所有基类构造函数传递参数。我们来看一下语法规定

**多继承时构造函数的定义语法**
```
派生类名::派生类名(参数表) : 
基类名1(基类1初始化参数表), 
基类名2(基类2初始化参数表), 
...
基类名n(基类n初始化参数表), 
本类成员初始化列表
{
        //其他初始化；
}；
```

**派生类与基类的构造函数**

* 当基类有默认构造函数时

  * 派生类构造函数可以不向基类构造函数传递参数。

  * 构造派生类的对象时，基类的默认构造函数将被调用。

* 如需执行基类中带参数的构造函数

  * 派生类构造函数应为基类构造函数提供参数。

**多继承且有对象成员时派生的构造函数定义语法**
```
派生类名::派生类名(形参表):
基类名1(参数), 基类名2(参数), ..., 基类名n(参数), 
本类成员（含对象成员）初始化列表
{
        //其他初始化
}；
```

**构造函数的执行顺序**

* 1 调用基类构造函数。

  * 当有多个基类时，调用顺序按照它们被继承时声明的顺序（从左向右）。

* 2 对初始化列表中的成员进行初始化。

  * 顺序按照它们在类中定义的顺序。

  * 对象成员初始化时自动调用其所属类的构造函数。
    
	* 由初始化列表提供参数。

* 3 执行派生类的构造函数体中的内容。

### 派生类构造函数举例(例7-4)

```
#include <iostream>
using namespace std;
class Base1 {//基类Base1，构造函数有参数
public:
    Base1(int i) 
  { cout << "Constructing Base1 " << i << endl; }
};
class Base2 {//基类Base2，构造函数有参数
public:
    Base2(int j) 
  { cout << "Constructing Base2 " << j << endl; }
};
class Base3 {//基类Base3，构造函数无参数
public:
    Base3() 
  { cout << "Constructing Base3 *" << endl; }
};

class Derived: public Base2, public Base1, public Base3 {
public: 
    Derived(int a, int b, int c, int d): Base1(a), member2(d), member1(c), Base2(b)
  //此处的次序与构造函数的执行次序无关
    { }
private:
    Base1 member1;
    Base2 member2;
    Base3 member3;
};

int main() {
    Derived obj(1, 2, 3, 4);
    return 0;
}

```


# 2 访问控制


# 3 类的兼容规则


# 4 派生类的构造和析构函数

# 5 派生类成员得标识与访问

