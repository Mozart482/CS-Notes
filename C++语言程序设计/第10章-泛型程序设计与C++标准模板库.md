# 1 泛型程序设计与C++标准模板库

## 1.1 泛型程序设计及STL的结构

### 泛型程序设计的基本概念

* 编写不依赖于具体数据类型的程序

* 将算法从特定的数据结构中抽象出来，成为通用的

* C++的模板为泛型程序设计奠定了关键的基础

**术语：概念**

* 用来界定具备一定功能的数据类型。例如：

  * 将“可以比大小的所有数据类型（有比较运算符）”这一概念记为**Comparable**

  * 将“具有公有的复制构造函数并可以用‘=’赋值的数据类型”这一概念记为**Assignable**

  * 将“可以比大小、具有公有的复制构造函数并可以用‘=’赋值的所有数据类型”这个概念记作**Sortable**

* 对于两个不同的概念A和B，如果概念A所需求的所有功能也是概念B所需求的功能，那么就说概念B是概念A的子概念。例如：

  * Sortable既是Comparable的子概念，也是Assignable的子概念

**术语：模型**

* 模型（model）：符合一个概念的数据类型称为该概念的模型，例如：

* int型是Comparable概念的模型。

* 静态数组类型不是Assignable概念的模型（无法用“=”给整个静态数组赋值）

**用概念做模板参数名**

* 很多STL的实现代码就是使用概念来命名模板参数的。

* 为概念赋予一个名称，并使用该名称作为模板参数名。

* 例如

  * 表示insertionSort这样一个函数模板的原型：
```
    template <class Sortable>
    void insertionSort(Sortable a[], int n);
```

### STL简介

**STL简介**

* 标准模板库（Standard Template Library，简称STL）定义了一套概念体系，为泛型程序设计提供了逻辑基础

* STL中的各个类模板、函数模板的参数都是用这个体系中的概念来规定的。

* 使用STL的模板时，类型参数既可以是C++标准库中已有的类型，也可以是自定义的类型——只要这些类型是所要求概念的模型。

**STL的基本组件**

* 容器（container）

* 迭代器（iterator）

* 函数对象（function object）

* 算法（algorithms）

**STL的基本组件间的关系**

* **Iterators（迭代器）**是**算法**和**容器**的桥梁。

  * 将迭代器作为算法的参数、通过迭代器来访问容器而不是把容器直接作为算法的参数。

* 将**函数对象**作为算法的参数而不是将函数所执行的运算作为算法的一部分。

* 使用STL中提供的或自定义的迭代器和函数对象，配合STL的算法，可以组合出各种各样的功能。

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/STL%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png)

**STL的基本组件——容器（container）**

* 容纳、包含一组元素的对象。

* 基本容器类模板

  * 顺序容器
  
  array（数组）、vector（向量）、deque（双端队列）、forward_list（单链表）、list（列表）

  * (有序)关联容器
  
  set（集合）、multiset（多重集合）、map（映射）、multimap（多重映射）

  * 无序关联容器
  
  unorderedset（无序集合）、unorderedmultiset（无序多重集合）

  unorderedmap（无序映射）、unordermultimap（无序多重映射）

* 容器适配器

  * stack（栈）、queue（队列）、priority_queue（优先队列）

* 使用容器，需要包含对应的头文件

**STL的基本组件——迭代器（iterator）**

* **迭代器是泛化的指针**，提供了顺序访问容器中每个元素的方法

* 可以使用“++”运算符来获得指向下一个元素的迭代器；

* 可以使用“\*”运算符访问一个迭代器所指向的元素，如果元素类型是类或结构体，还可以使用“->”运算符直接访问该元素的一个成员；

* 有些迭代器还支持通过“--”运算符获得指向上一个元素的迭代器；

* 迭代器是泛化的指针：指针也具有同样的特性，因此指针本身就是一种迭代器；

* 使用独立于STL容器的迭代器，需要包含头文件\<iterator\>

**STL的基本组件——函数对象（function object）**

* 一个行为类似函数的对象，对它可以像调用函数一样调用。

* **函数对象是泛化的函数**：任何普通的函数和任何重载了“()” 运算符的类的对象都可以作为函数对象使用

* 使用STL的函数对象，需要包含头文件\<functional\>

**STL的基本组件——算法（algorithms）**

* STL包括70多个算法

  * 例如：排序算法，消除算法，计数算法，比较算法，变换算法，置换算法和容器管理等

* 可以广泛用于不同的对象和内置的数据类型

* 使用STL的算法，需要包含头文件\<algorithm\>


**例10-1：STL程序实例**

* 从标准输入读入几个整数，存入向量容器，输出它们的相反数

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/STL%E7%A8%8B%E5%BA%8F%E5%AE%9E%E4%BE%8B.png)

**transform算法**

* transform算法的一种实现：

```
    template <class InputIterator, class OutputIterator, class UnaryFunction>
    OutputIterator transform(InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op) {
        for (;first != last; ++first, ++result)
            *result = op(*first);
        return result;
    }
```
* transform算法顺序遍历first和last两个迭代器所指向的元素；

* 将每个元素的值作为函数对象op的参数；

* 将op的返回值通过迭代器result顺序输出；

* 遍历完成后result迭代器指向的是输出的最后一个元素的下一个位置，transform会将该迭代器返回


## 1.2 迭代器

### 迭代器

* **迭代器是算法和容器的桥梁**

  * 迭代器用作访问容器中的元素

  * 算法不直接操作容器中的数据，而是通过迭代器间接操作

* **算法和容器独立**

  * 增加新的算法，无需影响容器的实现

  * 增加新的容器，原有的算法也能适用

**输入流迭代器和输出流迭代器**

* 输入流迭代器
```
	istream_iterator<T>
```
  * 以输入流（如cin）为参数构造

  * 可用\*(p++)获得下一个输入的元素

* 输出流迭代器
```
	ostream_iterator<T>
```
  * 构造时需要提供输出流（如cout）

  * 可用(\*p++) = x将x输出到输出流

* 二者都属于适配器

  * 适配器是用来为已有对象提供新的接口的对象

  * 输入流适配器和输出流适配器为流对象提供了迭代器的接口

**例10-2从标准输入读入几个实数，分别将它们的平方输出**
```
//10_2.cpp
#include <iterator>
#include <iostream>
#include <algorithm>
using namespace std;

//求平方的函数
double square(double x) {
    return x * x;
}
int main() {
    //从标准输入读入若干个实数，分别将它们的平方输出
    transform(istream_iterator<double>(cin), istream_iterator<double>(),
        ostream_iterator<double>(cout, "\t"), square);
    cout << endl;
    return 0;
}
```
**迭代器的分类**

[图片缺失]

**迭代器支持的操作**

* 迭代器是泛化的指针，提供了类似指针的操作（诸如++、\*、->运算符）

* 输入迭代器

  * 可以用来从序列中读取数据，如输入流迭代器

* 输出迭代器

  * 允许向序列中写入数据，如输出流迭代器

* 前向迭代器

  * 既是输入迭代器又是输出迭代器，并且可以对序列进行单向的遍历

* 双向迭代器

  * 与前向迭代器相似，但是在两个方向上都可以对数据遍历

* 随机访问迭代器

  * 也是双向迭代器，但能够在序列中的任意两个位置之间进行跳转，如指针、使用vector的begin()、end()函数得到的迭代器

**迭代器的区间**

* 两个迭代器表示一个区间：[p1, p2)

* STL算法常以迭代器的区间作为输入，传递输入数据

* 合法的区间

  * p1经过n次(n > 0)自增(++)操作后满足p1 == p2

* 区间包含p1，但不包含p2

**例10-3 综合运用几种迭代器的示例**

程序涉及到输入迭代器、输出迭代器、随机访问迭代器这三个迭代器概念，并且以前两个概念为基础编写了一个通用算法。
```
//10_3.cpp
#include <algorithm>
#include <iterator>
#include <vector>
#include <iostream>
using namespace std;

//将来自输入迭代器的n个T类型的数值排序，将结果通过输出迭代器result输出
template <class T, class InputIterator, class OutputIterator>
void mySort(InputIterator first, InputIterator last, OutputIterator result) {
    //通过输入迭代器将输入数据存入向量容器s中
    vector<T> s;
    for (;first != last; ++first)
        s.push_back(*first);
    //对s进行排序，sort函数的参数必须是随机访问迭代器
    sort(s.begin(), s.end());  
    copy(s.begin(), s.end(), result);   //将s序列通过输出迭代器输出
}

int main() {
    //将s数组的内容排序后输出
    double a[5] = { 1.2, 2.4, 0.8, 3.3, 3.2 };
    mySort<double>(a, a + 5, ostream_iterator<double>(cout, " "));
    cout << endl;
    //从标准输入读入若干个整数，将排序后的结果输出
    mySort<int>(istream_iterator<int>(cin), istream_iterator<int>(), ostream_iterator<int>(cout, " "));
    cout << endl;
    return 0;
}

/*
运行结果：
0.8 1.2 2.4 3.2 3.3
2 -4 5 8 -1 3 6 -5
-5 -4 -1 2 3 5 6 8
*/
```

**迭代器的辅助函数**

* advance(p, n)

  * 对p执行n次自增操作

* distance(first, last)

  * 计算两个迭代器first和last的距离，即对first执行多少次“++”操作后能够使得first == last

## 1.3 容器的基本功能与分类



## 1.4 顺序容器


## 1.5 关联容器


## 1.6 函数对象

