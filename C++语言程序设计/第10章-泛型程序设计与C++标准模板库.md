# 1 泛型程序设计与C++标准模板库

## 1.1 泛型程序设计及STL的结构

### 泛型程序设计的基本概念

* 编写不依赖于具体数据类型的程序

* 将算法从特定的数据结构中抽象出来，成为通用的

* C++的模板为泛型程序设计奠定了关键的基础

**术语：概念**

* 用来界定具备一定功能的数据类型。例如：

  * 将“可以比大小的所有数据类型（有比较运算符）”这一概念记为**Comparable**

  * 将“具有公有的复制构造函数并可以用‘=’赋值的数据类型”这一概念记为**Assignable**

  * 将“可以比大小、具有公有的复制构造函数并可以用‘=’赋值的所有数据类型”这个概念记作**Sortable**

* 对于两个不同的概念A和B，如果概念A所需求的所有功能也是概念B所需求的功能，那么就说概念B是概念A的子概念。例如：

  * Sortable既是Comparable的子概念，也是Assignable的子概念

**术语：模型**

* 模型（model）：符合一个概念的数据类型称为该概念的模型，例如：

* int型是Comparable概念的模型。

* 静态数组类型不是Assignable概念的模型（无法用“=”给整个静态数组赋值）

**用概念做模板参数名**

* 很多STL的实现代码就是使用概念来命名模板参数的。

* 为概念赋予一个名称，并使用该名称作为模板参数名。

* 例如

  * 表示insertionSort这样一个函数模板的原型：
```
    template <class Sortable>
    void insertionSort(Sortable a[], int n);
```

### STL简介

**STL简介**

* 标准模板库（Standard Template Library，简称STL）定义了一套概念体系，为泛型程序设计提供了逻辑基础

* STL中的各个类模板、函数模板的参数都是用这个体系中的概念来规定的。

* 使用STL的模板时，类型参数既可以是C++标准库中已有的类型，也可以是自定义的类型——只要这些类型是所要求概念的模型。

**STL的基本组件**

* 容器（container）

* 迭代器（iterator）

* 函数对象（function object）

* 算法（algorithms）

**STL的基本组件间的关系**

* **Iterators（迭代器）**是**算法**和**容器**的桥梁。

  * 将迭代器作为算法的参数、通过迭代器来访问容器而不是把容器直接作为算法的参数。

* 将**函数对象**作为算法的参数而不是将函数所执行的运算作为算法的一部分。

* 使用STL中提供的或自定义的迭代器和函数对象，配合STL的算法，可以组合出各种各样的功能。

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/STL%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E4%BB%B6%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png)

**STL的基本组件——容器（container）**

* 容纳、包含一组元素的对象。

* 基本容器类模板

  * 顺序容器
  
  array（数组）、vector（向量）、deque（双端队列）、forward_list（单链表）、list（列表）

  * (有序)关联容器
  
  set（集合）、multiset（多重集合）、map（映射）、multimap（多重映射）

  * 无序关联容器
  
  unorderedset（无序集合）、unorderedmultiset（无序多重集合）

  unorderedmap（无序映射）、unordermultimap（无序多重映射）

* 容器适配器

  * stack（栈）、queue（队列）、priority_queue（优先队列）

* 使用容器，需要包含对应的头文件

**STL的基本组件————迭代器（iterator）**

* **迭代器是泛化的指针**，提供了顺序访问容器中每个元素的方法

* 可以使用“++”运算符来获得指向下一个元素的迭代器；

* 可以使用“\*”运算符访问一个迭代器所指向的元素，如果元素类型是类或结构体，还可以使用“->”运算符直接访问该元素的一个成员；

* 有些迭代器还支持通过“--”运算符获得指向上一个元素的迭代器；

* 迭代器是泛化的指针：指针也具有同样的特性，因此指针本身就是一种迭代器；

* 使用独立于STL容器的迭代器，需要包含头文件<iterator>

**STL的基本组件————函数对象（function object）**

* 一个行为类似函数的对象，对它可以像调用函数一样调用。

* **函数对象是泛化的函数**：任何普通的函数和任何重载了“()” 运算符的类的对象都可以作为函数对象使用

* 使用STL的函数对象，需要包含头文件<functional>

**STL的基本组件————算法（algorithms）**

* STL包括70多个算法

  * 例如：排序算法，消除算法，计数算法，比较算法，变换算法，置换算法和容器管理等

* 可以广泛用于不同的对象和内置的数据类型

* 使用STL的算法，需要包含头文件<algorithm>


**例10-1：STL程序实例**

* 从标准输入读入几个整数，存入向量容器，输出它们的相反数

transform算法的一种实现：
```
    template <class InputIterator, class OutputIterator, class UnaryFunction>
    OutputIterator transform(InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op) {
        for (;first != last; ++first, ++result)
            *result = op(*first);
        return result;
    }
```
* transform算法顺序遍历first和last两个迭代器所指向的元素；

* 将每个元素的值作为函数对象op的参数；

* 将op的返回值通过迭代器result顺序输出；

* 遍历完成后result迭代器指向的是输出的最后一个元素的下一个位置，transform会将该迭代器返回




## 1.2 迭代器



## 1.3 容器的基本功能与分类



## 1.4 顺序容器


## 1.5 关联容器


## 1.6 函数对象

