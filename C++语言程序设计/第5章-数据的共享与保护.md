# 1 标识符的作用域与可见性
## 1.1 作用域
  * 作用域是一个标识符在程序正文中有效的区域。
  * 作用域分类：
  
    1.函数原型作用域
    
    2.局部作用域(块作用域)
    
    3.类作用域
    
    4.文件作用域
    
    5.命名空间作用域
### 函数原型作用域
* 函数原型中的参数，其作用域始于"("，结束于")"。
* 函数原型作用域举例
```
	double area(double radius);
```
### 局部作用域
* 函数的形参、在块中声明的标识符；
* 其作用域自声明处起，限于块中。
* 局部作用域举例：
```
void fun(int a) {
   int b = a;
   cin >> b;
   if (b > 0) {
     int c;

     ......
   }
}
```
### 类作用域
* 类的成员具有类作用域，其范围包括类体和非内联成员函数的函数体。
* 如果在类作用域以外访问类的成员，要通过类名（访问静态成员），或者该类的对象名、对象引用、对象指针（访问非静态成员）。
### 文件作用域
* 不在前述各个作用域中出现的声明，就具有文件作用域，这样声明的标识符其作用域开始于声明点，结束于文件尾。

## 1.2 可见性
* 可见性是从对标识符的引用的角度来谈的概念
* 可见性表示从内层作用域向外层作用域“看”时能看见什么。
* 如果标识在某处可见，就可以在该处引用此标识符。
* 如果某个标识符在外层中声明，且在内层中没有同一标识符的声明，则该标识符在内层可见。
* 对于两个嵌套的作用域，如果在内层作用域内声明了与外层作用域中同名的标识符，则外层作用域的标识符在内层不可见。
**例5-1**
```
int i;	//全局变量，文件作用域
int main() { 
     i = 5; //为全局变量i赋值
     {
         int i; //局部变量，局部作用域
         i = 7;
         cout << "i = " << i << endl;//输出7
      }
      cout << “i = ” << i << endl;//输出5
      return 0;
}
```

# 2 对象的生存期
## 2.1 静态生存期
* 这种生存期与程序的运行期相同。
* 在文件作用域中声明的对象具有这种生存期。
* 在函数内部声明静态生存期对象，要冠以关键字static 。
## 2.2 动态生存期
* 块作用域中声明的，没有用static修饰的对象是动态生存期的对象（习惯称局部生存期对象）。
* 开始于程序执行到声明点时，结束于命名该标识符的作用域结束处。

**例5-2变量的生存期与可见性**
```
	#include<iostream>
	using namespace std;
	int i = 1; // i 为全局变量，具有静态生存期。
	
	void other() {
	static int a = 2;
	static int b;
	// a,b为静态局部变量，具有全局寿命，局部可见。
	// 只第一次进入函数时被初始化。
	int c = 10; 
	// c为局部变量，具有动态生存期，
	// 每次进入函数时都初始化。
	a += 2; i += 32; c += 5;
	cout<<"---OTHER---\n";
	cout<<" i: "<<i<<" a: "<<a<<" b: "<<b<<" c: "<<c<<endl;
	b = a;
	}

	int main() {
	static int a;//静态局部变量，有全局寿命，局部可见。
	int b = -10; // b, c为局部变量，具有动态生存期。
	int c = 0;
	cout << "---MAIN---\n";
	cout<<" i: "<<i<<" a: "<<a<<" b: "<<b<<" c: "<<c<<endl;
	c += 8; other();
	cout<<"---MAIN---\n";
	cout<<" i: "<<i<<" a: "<<a<<" b: "<<b<<" c: "<<c<<endl;
	i += 10; other();  
	return 0;
}
```
# 3 类的静态成员
## 3.1 静态数据成员
* 用关键字static声明
* 为该类的所有对象共享，静态数据成员具有静态生存期
* 必须在类外定义和初始化，用(::)来指明所属的类
## 3.2 静态函数成员
* 类外代码可以使用类名和作用域操作符来调用静态成员函数。
* 静态成员函数主要用于处理该类的静态数据成员，可以直接调用静态成员函数。
* 如果访问非静态成员，要通过对象来访问。

# 4 类的友元
* 友元是C++提供的一种破坏数据封装和数据隐藏的机制。
* 通过将一个模块声明为另一个模块的友元，一个模块能够引用到另一个模块中本是被隐藏的信息。
* 可以使用友元函数和友元类。
* 为了确保数据的完整性，及数据封装与隐藏的原则，建议尽量不使用或少使用友元。
## 4.1 友元函数
* 友元函数是在类声明中由关键字friend修饰说明的非成员函数，在它的函数体中能够通过对象名访问 private 和 protected成员
* 作用：增加灵活性，使程序员可以在封装和快速性方面做合理选择。
* 访问对象中的成员必须通过对象名。
## 4.2 友元类
* 若一个类为另一个类的友元，则此类的所有成员都能访问对方类的私有成员。
* 声明语法：将友元类名在另一个类中使用friend修饰说明。
**类的友元关系是单向的**
* 如果声明B类是A类的友元，B类的成员函数就可以访问A类的私有和保护数据，但A类的成员函数却不能访问B类的私有、保护数据。
# 5 共享数据的保护
* 对于既需要共享、又需要防止改变的数据应该声明为**常类型**（用const进行修饰）。
* 对于不改变对象状态的成员函数应该声明为**常函数**。
## 常类型
* 常对象：必须进行初始化,不能被更新。
* const 类名 对象名
##  常成员
* 用const进行修饰的类成员：常数据成员和常函数成员
## 常引用：被引用的对象不能被更新。
*  const  类型说明符  &引用名
## 常数组：数组元素不能被更新(详见第6章)。
*   类型说明符  const  数组名[大小]...
# 6 多文件结构的编译预处理命令
