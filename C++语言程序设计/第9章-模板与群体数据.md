# 1 æ¨¡æ¿ä¸ç¾¤ä½“æ•°æ®

## 1.1 æ¨¡æ¿

### å‡½æ•°æ¨¡æ¿
* æ€è€ƒï¼šå¦‚æœé‡è½½çš„å‡½æ•°ï¼Œå…¶è§£å†³é—®é¢˜çš„é€»è¾‘æ˜¯ä¸€è‡´çš„ã€å‡½æ•°ä½“è¯­å¥ç›¸åŒï¼Œåªæ˜¯å¤„ç†çš„æ•°æ®ç±»å‹ä¸åŒï¼Œé‚£ä¹ˆå†™å¤šä¸ªç›¸åŒçš„å‡½æ•°ä½“ï¼Œæ˜¯é‡å¤åŠ³åŠ¨ï¼Œè€Œä¸”è¿˜å¯èƒ½å› ä¸ºä»£ç çš„å†—ä½™é€ æˆä¸ä¸€è‡´æ€§ã€‚

* è§£å†³ï¼šä½¿ç”¨æ¨¡æ¿

ä¾‹ï¼šæ±‚ç»å¯¹å€¼å‡½æ•°çš„æ¨¡æ¿

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/%E6%B1%82%E7%BB%9D%E5%AF%B9%E5%80%BC%E5%87%BD%E6%95%B0%E7%9A%84%E6%A8%A1%E6%9D%BF1.png)

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/%E6%B1%82%E7%BB%9D%E5%AF%B9%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF2.png)

**å‡½æ•°æ¨¡æ¿å®šä¹‰è¯­æ³•**

* è¯­æ³•å½¢å¼ï¼š
```
	template <æ¨¡æ¿å‚æ•°è¡¨>
	å‡½æ•°å®šä¹‰
```

* æ¨¡æ¿å‚æ•°è¡¨çš„å†…å®¹

  * **ç±»å‹å‚æ•°ï¼šclassï¼ˆæˆ–typenameï¼‰ æ ‡è¯†ç¬¦**

  * å¸¸é‡å‚æ•°ï¼šç±»å‹è¯´æ˜ç¬¦ æ ‡è¯†ç¬¦

  * æ¨¡æ¿å‚æ•°ï¼štemplate <å‚æ•°è¡¨> classæ ‡è¯†ç¬¦
  
**ä¾‹9-1 å‡½æ•°æ¨¡æ¿çš„ç¤ºä¾‹**
```
//9_1.cpp
#include <iostream>
using namespace std;

template <class T>  //å®šä¹‰å‡½æ•°æ¨¡æ¿
void outputArray(const T *array, int count) {
    for (int i = 0; i < count; i++)
        cout << array[i] << " "; //å¦‚æœæ•°ç»„å…ƒç´ æ˜¯ç±»çš„å¯¹è±¡ï¼Œéœ€è¦è¯¥å¯¹è±¡æ‰€å±ç±»é‡è½½äº†æµæ’å…¥è¿ç®—ç¬¦â€œ<<â€
    cout << endl;
}

int main() {     
    const int A_COUNT = 8, B_COUNT = 8, C_COUNT = 20;
    int a [A_COUNT] = { 1, 2, 3, 4, 5, 6, 7, 8 };
    double b[B_COUNT] = { 1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8 };
    char c[C_COUNT] = "Welcome!";

    cout << " a array contains:" << endl;
    outputArray(a, A_COUNT);    
    cout << " b array contains:" << endl;
    outputArray(b, B_COUNT);    
    cout << " c array contains:" << endl;
    outputArray(c, C_COUNT);    
    return 0;
}
```

è¿è¡Œç»“æœå¦‚ä¸‹ï¼š
```
a array contains:
1 2 3 4 5 6 7 8
b array contains:
1.1 2.2 3.3 4.4 5.5 6.6 7.7 8.8 
c array contains:
W e l c o m e!
```
**æ³¨æ„**

* ä¸€ä¸ªå‡½æ•°æ¨¡æ¿å¹¶éè‡ªåŠ¨å¯ä»¥å¤„ç†æ‰€æœ‰ç±»å‹çš„æ•°æ®

* åªæœ‰èƒ½å¤Ÿè¿›è¡Œå‡½æ•°æ¨¡æ¿ä¸­è¿ç®—çš„ç±»å‹ï¼Œå¯ä»¥ä½œä¸ºç±»å‹å®å‚

* è‡ªå®šä¹‰çš„ç±»ï¼Œéœ€è¦é‡è½½æ¨¡æ¿ä¸­çš„è¿ç®—ç¬¦ï¼Œæ‰èƒ½ä½œä¸ºç±»å‹å®å‚



###  ç±»æ¨¡æ¿

**ç±»æ¨¡æ¿çš„ä½œç”¨**

ä½¿ç”¨ç±»æ¨¡æ¿ä½¿ç”¨æˆ·å¯ä»¥ä¸ºç±»å£°æ˜ä¸€ç§æ¨¡å¼ï¼Œä½¿å¾—ç±»ä¸­çš„æŸäº›æ•°æ®æˆå‘˜ã€æŸäº›æˆå‘˜å‡½æ•°çš„å‚æ•°ã€æŸäº›æˆå‘˜å‡½æ•°çš„è¿”å›å€¼ï¼Œèƒ½å–ä»»æ„ç±»å‹ï¼ˆåŒ…æ‹¬åŸºæœ¬ç±»å‹çš„å’Œç”¨æˆ·è‡ªå®šä¹‰ç±»å‹ï¼‰ã€‚

*å¯ä»¥ä½¿ç”¨ç±»æ¨¡æ¿ç”Ÿæˆç‰¹å®šæ•°æ®ç±»å‹çš„ç±»

**ç±»æ¨¡æ¿çš„å£°æ˜**

* ç±»æ¨¡æ¿è¯­æ³• 
```
	template <æ¨¡æ¿å‚æ•°è¡¨> 
	class ç±»å 
	{ç±»æˆå‘˜å£°æ˜};
```

* å¦‚æœéœ€è¦åœ¨ç±»æ¨¡æ¿ä»¥å¤–å®šä¹‰å…¶æˆå‘˜å‡½æ•°ï¼Œåˆ™è¦é‡‡ç”¨ä»¥ä¸‹çš„å½¢å¼ï¼š 
```
	template <æ¨¡æ¿å‚æ•°è¡¨> 
	ç±»å‹å ç±»å<æ¨¡æ¿å‚æ•°æ ‡è¯†ç¬¦åˆ—è¡¨>::å‡½æ•°åï¼ˆå‚æ•°è¡¨ï¼‰
```
**ä¾‹9-2 ç±»æ¨¡æ¿ç¤ºä¾‹**
```
#include <iostream>
#include <cstdlib>
using namespace std;
struct Student {
  int id;       //å­¦å·
  float gpa;    //å¹³å‡åˆ†
}; 
template <class T>
class Store {//ç±»æ¨¡æ¿ï¼šå®ç°å¯¹ä»»æ„ç±»å‹æ•°æ®è¿›è¡Œå­˜å–
private:
    T item; // itemç”¨äºå­˜æ”¾ä»»æ„ç±»å‹çš„æ•°æ®
    bool haveValue;  // haveValueæ ‡è®°itemæ˜¯å¦å·²è¢«å­˜å…¥å†…å®¹
public:
    Store();
    T &getElem();   //æå–æ•°æ®å‡½æ•°
    void putElem(const T &x);  //å­˜å…¥æ•°æ®å‡½æ•°
};

template <class T>  
Store<T>::Store(): haveValue(false) { } 

template <class T>
T &Store<T>::getElem() {
    //å¦‚è¯•å›¾æå–æœªåˆå§‹åŒ–çš„æ•°æ®ï¼Œåˆ™ç»ˆæ­¢ç¨‹åº
    if (!haveValue) {   
        cout << "No item present!" << endl;
        exit(1);    //ä½¿ç¨‹åºå®Œå…¨é€€å‡ºï¼Œè¿”å›åˆ°æ“ä½œç³»ç»Ÿã€‚
    }
    return item;        // è¿”å›itemä¸­å­˜æ”¾çš„æ•°æ® 
}

template <class T>
void Store<T>::putElem(const T &x) {
    // å°†haveValue ç½®ä¸ºtrueï¼Œè¡¨ç¤ºitemä¸­å·²å­˜å…¥æ•°å€¼   
    haveValue = true;   
    item = x;           // å°†xå€¼å­˜å…¥item
}

int main() {
    Store<int> s1, s2;  
    s1.putElem(3);  
    s2.putElem(-7);
    cout << s1.getElem() << "  " << s2.getElem() << endl;

    Student g = { 1000, 23 };
    Store<Student> s3;
    s3.putElem(g); 
    cout << "The student id is " << s3.getElem().id << endl;

    Store<double> d;
    cout << "Retrieving object D... ";
    cout << d.getElem() << endl;
   //dæœªåˆå§‹åŒ–ï¼Œæ‰§è¡Œå‡½æ•°D.getElement()æ—¶å¯¼è‡´ç¨‹åºç»ˆæ­¢
    return 0;
}
```

## 1.2 çº¿æ€§ç¾¤ä½“

### çº¿æ€§ç¾¤ä½“çš„æ¦‚å¿µ

* **ç¾¤ä½“**æ˜¯æŒ‡ç”±å¤šä¸ªæ•°æ®å…ƒç´ ç»„æˆçš„é›†åˆä½“ã€‚

 * ç¾¤ä½“å¯ä»¥åˆ†ä¸ºä¸¤ä¸ªå¤§ç±»ï¼š**çº¿æ€§ç¾¤ä½“**å’Œ**éçº¿æ€§ç¾¤ä½“**ã€‚

* **çº¿æ€§ç¾¤ä½“**ä¸­çš„å…ƒç´ æŒ‰ä½ç½®æ’åˆ—æœ‰åºï¼Œå¯ä»¥åŒºåˆ†ä¸ºç¬¬ä¸€ä¸ªå…ƒç´ ã€ç¬¬äºŒä¸ªå…ƒç´ ç­‰ã€‚

* **éçº¿æ€§ç¾¤ä½“**ä¸ç”¨ä½ç½®é¡ºåºæ¥æ ‡è¯†å…ƒç´ ã€‚

* **çº¿æ€§ç¾¤ä½“**ä¸­çš„å…ƒç´ æ¬¡åºä¸å…¶é€»è¾‘ä½ç½®å…³ç³»æ˜¯å¯¹åº”çš„ã€‚åœ¨çº¿æ€§ç¾¤ä½“ä¸­ï¼Œåˆå¯æŒ‰ç…§è®¿é—®å…ƒç´ çš„ä¸åŒæ–¹æ³•åˆ†ä¸º**ç›´æ¥è®¿é—®**ã€**é¡ºåºè®¿é—®**å’Œ**ç´¢å¼•è®¿é—®**ã€‚

* åœ¨æœ¬ç« æˆ‘ä»¬åªä»‹ç»ç›´æ¥è®¿é—®å’Œé¡ºåºè®¿é—®ã€‚

## 1.3 æ•°ç»„

### æ•°ç»„ç±»æ¨¡æ¿

* **é™æ€æ•°ç»„**æ˜¯å…·æœ‰å›ºå®šå…ƒç´ ä¸ªæ•°çš„ç¾¤ä½“ï¼Œå…¶ä¸­çš„å…ƒç´ å¯ä»¥é€šè¿‡ä¸‹æ ‡ç›´æ¥è®¿é—®ã€‚

  * **ç¼ºç‚¹**ï¼šå¤§å°åœ¨ç¼–è¯‘æ—¶å°±å·²ç»ç¡®å®šï¼Œåœ¨è¿è¡Œæ—¶æ— æ³•ä¿®æ”¹ã€‚

* **åŠ¨æ€æ•°ç»„**ç”±ä¸€ç³»åˆ—ä½ç½®è¿ç»­çš„ï¼Œä»»æ„æ•°é‡ç›¸åŒç±»å‹çš„å…ƒç´ ç»„æˆã€‚

  * **ä¼˜ç‚¹**ï¼šå…¶å…ƒç´ ä¸ªæ•°å¯åœ¨ç¨‹åºè¿è¡Œæ—¶æ”¹å˜ã€‚

* vectorå°±æ˜¯ç”¨ç±»æ¨¡æ¿å®ç°çš„åŠ¨æ€æ•°ç»„ã€‚

**ä¾‹9-3 åŠ¨æ€æ•°ç»„ç±»æ¨¡æ¿ç¨‹åº**
```
#ifndef ARRAY_H
#define ARRAY_H
#include <cassert>

template <class T>  //æ•°ç»„ç±»æ¨¡æ¿å®šä¹‰
class Array {
private:
    T* list;        //ç”¨äºå­˜æ”¾åŠ¨æ€åˆ†é…çš„æ•°ç»„å†…å­˜é¦–åœ°å€
    int size;       //æ•°ç»„å¤§å°ï¼ˆå…ƒç´ ä¸ªæ•°ï¼‰
public:
    Array(int sz = 50);     //æ„é€ å‡½æ•°
    Array(const Array<T> &a);   //å¤åˆ¶æ„é€ å‡½æ•°
    ~Array();           //ææ„å‡½æ•°
    Array<T> & operator = (const Array<T> &rhs);    //é‡è½½"=â€œ
    T & operator [] (int i); //é‡è½½"[]â€
    const T & operator [] (int i) const;     //é‡è½½"[]â€å¸¸å‡½æ•°
    operator T * ();        //é‡è½½åˆ°T*ç±»å‹çš„è½¬æ¢
    operator const T * () const;
    int getSize() const;        //å–æ•°ç»„çš„å¤§å°
    void resize(int sz);        //ä¿®æ”¹æ•°ç»„çš„å¤§å°
};

template <class T> Array<T>::Array(int sz) {//æ„é€ å‡½æ•°
    assert(sz >= 0);//szä¸ºæ•°ç»„å¤§å°ï¼ˆå…ƒç´ ä¸ªæ•°ï¼‰ï¼Œåº”å½“éè´Ÿ
    size = sz;  // å°†å…ƒç´ ä¸ªæ•°èµ‹å€¼ç»™å˜é‡size
    list = new T [size];    //åŠ¨æ€åˆ†é…sizeä¸ªTç±»å‹çš„å…ƒç´ ç©ºé—´
}

template <class T> Array<T>::~Array() { //ææ„å‡½æ•°
    delete [] list;
}

template <class T> 
Array<T>::Array(const Array<T> &a) {    //å¤åˆ¶æ„é€ å‡½æ•°
    size = a.size;     //ä»å¯¹è±¡xå–å¾—æ•°ç»„å¤§å°ï¼Œå¹¶èµ‹å€¼ç»™å½“å‰å¯¹è±¡çš„æˆå‘˜
    list = new T[size]; // åŠ¨æ€åˆ†é…nä¸ªTç±»å‹çš„å…ƒç´ ç©ºé—´
    for (int i = 0; i < size; i++)     //ä»å¯¹è±¡Xå¤åˆ¶æ•°ç»„å…ƒç´ åˆ°æœ¬å¯¹è±¡ 
        list[i] = a.list[i];
}
```

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/%E6%95%B0%E7%BB%84%E7%B1%BB%E6%A8%A1%E6%9D%BF.png)


**ä¸ºä»€ä¹ˆæœ‰çš„å‡½æ•°è¿”å›å¼•ç”¨**

* å¦‚æœä¸€ä¸ªå‡½æ•°çš„è¿”å›å€¼æ˜¯ä¸€ä¸ªå¯¹è±¡çš„å€¼ï¼Œå°±æ˜¯å³å€¼ï¼Œä¸èƒ½æˆä¸ºå·¦å€¼ã€‚

* å¦‚æœè¿”å›å€¼ä¸ºå¼•ç”¨ã€‚ç”±äºå¼•ç”¨æ˜¯å¯¹è±¡çš„åˆ«åï¼Œé€šè¿‡å¼•ç”¨å¯ä»¥æ”¹å˜å¯¹è±¡çš„å€¼ï¼Œå› æ­¤æ˜¯å·¦å€¼ã€‚

```
//ç»­ä¸Š
//é‡è½½"="è¿ç®—ç¬¦ï¼Œå°†å¯¹è±¡rhsèµ‹å€¼ç»™æœ¬å¯¹è±¡ã€‚å®ç°å¯¹è±¡ä¹‹é—´çš„æ•´ä½“èµ‹å€¼
template <class T>
Array<T> &Array<T>::operator = (const Array<T>& rhs) {
    if (&rhs != this) {
//å¦‚æœæœ¬å¯¹è±¡ä¸­æ•°ç»„å¤§å°ä¸rhsä¸åŒï¼Œåˆ™åˆ é™¤æ•°ç»„åŸæœ‰å†…å­˜ï¼Œç„¶åé‡æ–°åˆ†é…
        if (size != rhs.size) {
            delete [] list; //åˆ é™¤æ•°ç»„åŸæœ‰å†…å­˜
            size = rhs.size;    //è®¾ç½®æœ¬å¯¹è±¡çš„æ•°ç»„å¤§å°
            list = new T[size];  //é‡æ–°åˆ†é…sizeä¸ªå…ƒç´ çš„å†…å­˜
        }
        //ä»å¯¹è±¡Xå¤åˆ¶æ•°ç»„å…ƒç´ åˆ°æœ¬å¯¹è±¡  
        for (int i = 0; i < size; i++)
            list[i] = rhs.list[i];
    }
    return *this;   //è¿”å›å½“å‰å¯¹è±¡çš„å¼•ç”¨
}

//é‡è½½ä¸‹æ ‡è¿ç®—ç¬¦ï¼Œå®ç°ä¸æ™®é€šæ•°ç»„ä¸€æ ·é€šè¿‡ä¸‹æ ‡è®¿é—®å…ƒç´ ï¼Œå…·æœ‰è¶Šç•Œæ£€æŸ¥åŠŸèƒ½
template <class T>
T &Array<T>::operator[] (int n) {
    assert(n >= 0 && n < size);  //æ£€æŸ¥ä¸‹æ ‡æ˜¯å¦è¶Šç•Œ
    return list[n];       //è¿”å›ä¸‹æ ‡ä¸ºnçš„æ•°ç»„å…ƒç´ 
}
template <class T>
const T &Array<T>::operator[] (int n) const {
    assert(n >= 0 && n < size);  //æ£€æŸ¥ä¸‹æ ‡æ˜¯å¦è¶Šç•Œ
    return list[n];       //è¿”å›ä¸‹æ ‡ä¸ºnçš„æ•°ç»„å…ƒç´ 
}
//é‡è½½æŒ‡é’ˆè½¬æ¢è¿ç®—ç¬¦ï¼Œå°†Arrayç±»çš„å¯¹è±¡åè½¬æ¢ä¸ºTç±»å‹çš„æŒ‡é’ˆ
template <class T>
Array<T>::operator T * () {
    return list;    //è¿”å›å½“å‰å¯¹è±¡ä¸­ç§æœ‰æ•°ç»„çš„é¦–åœ°å€
}

//å–å½“å‰æ•°ç»„çš„å¤§å°
template <class T>
int Array<T>::getSize() const {
    return size;
}

// å°†æ•°ç»„å¤§å°ä¿®æ”¹ä¸ºsz
template <class T>
void Array<T>::resize(int sz) {
    assert(sz >= 0);    //æ£€æŸ¥szæ˜¯å¦éè´Ÿ
    if (sz == size) //å¦‚æœæŒ‡å®šçš„å¤§å°ä¸åŸæœ‰å¤§å°ä¸€æ ·ï¼Œä»€ä¹ˆä¹Ÿä¸åš
        return;
    T* newList = new T [sz];    //ç”³è¯·æ–°çš„æ•°ç»„å†…å­˜
    int n = (sz < size) ? sz : size;//å°†szä¸sizeä¸­è¾ƒå°çš„ä¸€ä¸ªèµ‹å€¼ç»™n
    //å°†åŸæœ‰æ•°ç»„ä¸­å‰nä¸ªå…ƒç´ å¤åˆ¶åˆ°æ–°æ•°ç»„ä¸­
    for (int i = 0; i < n; i++)
        newList[i] = list[i];
    delete[] list;      //åˆ é™¤åŸæ•°ç»„
    list = newList; // ä½¿listæŒ‡å‘æ–°æ•°ç»„
    size = sz;  //æ›´æ–°size
}
#endif  //ARRAY_H
```

**æŒ‡é’ˆè½¬æ¢è¿ç®—ç¬¦çš„ä½œç”¨**
```
#include <iostream>
using namespace std;

void read(int *p, int n) {
 for (int i = 0; i < n; i++)
    cin >> p[i];
}
int main() {
 int a[10];
 read(a, 10);
 return 0;
}

#include "Array.h"
#include <iostream>
using namespace std;

void read(int *p, int n) {
 for (int i = 0; i < n; i++)
   cin >> p[i];
}
int main() {
Array<int> a(10);
 read(a, 10);
 return 0;
}
```

### ä¾‹9-4 æ•°ç»„ç±»åº”ç”¨ä¸¾ä¾‹

* æ±‚èŒƒå›´2~Nä¸­çš„è´¨æ•°ï¼ŒNåœ¨ç¨‹åºè¿è¡Œæ—¶ç”±é”®ç›˜è¾“å…¥ã€‚
```
#include <iostream>
#include <iomanip>
#include "Array.h"
using namespace std;
int main() {
    // ç”¨æ¥å­˜æ”¾è´¨æ•°çš„æ•°ç»„ï¼Œåˆå§‹çŠ¶æ€æœ‰10ä¸ªå…ƒç´ 
	Array<int> a(10);
    int n, count = 0;
    cout << "Enter a value >= 2 as upper limit for prime numbers: ";
    cin >> n;

    for (int i = 2; i <= n; i++) { //æ£€æŸ¥iæ˜¯å¦èƒ½è¢«æ¯”å®ƒå°çš„è´¨æ•°æ•´é™¤
      bool isPrime = true;
      
	  for (int j = 0; j < count; j++)
        //è‹¥iè¢«a[j]æ•´é™¤ï¼Œè¯´æ˜iä¸æ˜¯è´¨æ•°
           if (i % a[j] == 0) { 
          isPrime = false; break;
        }
      
	  if (isPrime) { 
        if (count == a.getSize())
               a.resize(count * 2);
        a[count++] = i;
      }
	  
    }
	
    for (int i = 0; i < count; i++) 
      cout << setw(8) << a[i];
    cout << endl;
    return 0;
}
```
* **ç–‘é—®**ï¼šåˆ¤æ–­ä¸€ä¸ªæ•°æ˜¯ä¸æ˜¯è´¨æ•°çš„æ—¶å€™ï¼Œä¸ºä»€ä¹ˆåªç”¨æ¯”å®ƒå°çš„è´¨æ•°ä¸å…¶è¿›è¡Œå–ä½™è¿ç®—ï¼Œä¸æ˜¯åº”è¯¥ç”¨æ‰€æœ‰æ¯”å…¶å°çš„æ•°éå†å—ï¼Ÿ

## 1.4 é“¾è¡¨ï¼ˆä½œä¸ºè¡¥å……ï¼Œå¯ä»¥çœ‹é‚“å…¬çš„æ•°æ®ç»“æ„è¯¾ç¨‹ğŸ™‚ï¼‰

### é“¾è¡¨çš„æ¦‚å¿µä¸ç»“ç‚¹ç±»æ¨¡æ¿

**é¡ºåºè®¿é—®çš„çº¿æ€§ç¾¤ä½“â€”â€”â€”â€”é“¾è¡¨ç±»**

* **é“¾è¡¨**æ˜¯ä¸€ç§åŠ¨æ€æ•°æ®ç»“æ„ï¼Œå¯ä»¥ç”¨æ¥è¡¨ç¤ºé¡ºåºè®¿é—®çš„çº¿æ€§ç¾¤ä½“ã€‚

* é“¾è¡¨æ˜¯ç”±ç³»åˆ—**ç»“ç‚¹**ç»„æˆçš„ï¼Œç»“ç‚¹å¯ä»¥åœ¨è¿è¡Œæ—¶åŠ¨æ€ç”Ÿæˆã€‚

* æ¯ä¸€ä¸ªç»“ç‚¹åŒ…æ‹¬**æ•°æ®åŸŸ**å’ŒæŒ‡å‘é“¾è¡¨ä¸­ä¸‹ä¸€ä¸ªç»“ç‚¹çš„**æŒ‡é’ˆ**ï¼ˆå³ä¸‹ä¸€ä¸ªç»“ç‚¹çš„åœ°å€ï¼‰ã€‚å¦‚æœé“¾è¡¨æ¯ä¸ªç»“ç‚¹ä¸­åªæœ‰ä¸€ä¸ªæŒ‡å‘åç»§ç»“ç‚¹çš„æŒ‡é’ˆï¼Œåˆ™è¯¥é“¾è¡¨ç§°ä¸º**å•é“¾è¡¨**ã€‚

**å•é“¾è¡¨**

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/%E5%8D%95%E9%93%BE%E8%A1%A8.png)

**å•é“¾è¡¨çš„ç»“ç‚¹ç±»æ¨¡æ¿**
```
template <class T>
class Node {
private:
	Node<T> *next;
public:
	T data;
	Node(const T&item, Node<T>* next = 0);
	void insertAfter(Node<T> *p);
	Node<T> *deleteAfter();
	Node<T> *nextNode() const;
};
```

**åœ¨ç»“ç‚¹ä¹‹åæ’å…¥ä¸€ä¸ªç»“ç‚¹**
![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/%E5%9C%A8%E7%BB%93%E7%82%B9%E5%90%8E%E6%8F%92%E5%85%A5%E4%B8%80%E4%B8%AA%E7%BB%93%E7%82%B9.png)

* æ³¨æ„ï¼šé¦–å…ˆä»¤æ–°ç»“ç‚¹çš„åç»§æŒ‡é’ˆæŒ‡å‘data2ï¼Œå†ä»¤data1çš„åç»§æŒ‡é’ˆæŒ‡å‘æ–°ç»“ç‚¹ï¼Œé¡ºåºä¸å¯å˜æ›´ï¼›

* å¾ªä½ç½®è®¿é—®ï¼šå…ˆæ–­å¼€data1åˆ°data2çš„è”ç³»ï¼Œdata2å°±ä¸¢äº†ï¼›

```
template <class T>

void Node<T>::insertAfter(Node<T> \*p) {

  //pèŠ‚ç‚¹æŒ‡é’ˆåŸŸæŒ‡å‘å½“å‰èŠ‚ç‚¹çš„åç»§èŠ‚ç‚¹

  p->next = next;

  next = p; //å½“å‰èŠ‚ç‚¹çš„æŒ‡é’ˆåŸŸæŒ‡å‘p

}
```

**åˆ é™¤ç»“ç‚¹ä¹‹åçš„ç»“ç‚¹**

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E4%B9%8B%E5%90%8E%E7%9A%84%E7%BB%93%E7%82%B9.png)

```
Node<T> *Node<T>::deleteAfter(void) {
  Node<T> *tempPtr = next;  
  if (next == 0) 
     return 0;
  next = tempPtr->next; 
  return tempPtr;   
}
```

**ä¾‹9-5 ç»“ç‚¹ç±»æ¨¡æ‰³**

```
//Node.h
#ifndef NODE_H
#define NODE_H
//ç±»æ¨¡æ¿çš„å®šä¹‰
template <class T>
class Node {
private:
    Node<T> *next;  //æŒ‡å‘åç»§ç»“ç‚¹çš„æŒ‡é’ˆ
public:
    T data; //æ•°æ®åŸŸ
    Node (const T &data, Node<T> *next = 0);    //æ„é€ å‡½æ•°
    void insertAfter(Node<T> *p);   //åœ¨æœ¬ç»“ç‚¹ä¹‹åæ’å…¥ä¸€ä¸ªåŒç±»ç»“ç‚¹p 
    Node<T> *deleteAfter(); //åˆ é™¤æœ¬ç»“ç‚¹çš„åç»§ç»“ç‚¹ï¼Œå¹¶è¿”å›å…¶åœ°å€
    Node<T> *nextNode();            //è·å–åç»§ç»“ç‚¹çš„åœ°å€
    const Node<T> *nextNode() const;     //è·å–åç»§ç»“ç‚¹çš„åœ°å€
};

//ç±»çš„å®ç°éƒ¨åˆ†
//æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–æ•°æ®å’ŒæŒ‡é’ˆæˆå‘˜
template <class T>
Node<T>::Node(const T& data, Node<T> *next = 0 ) : data(data), next(next) { }
//è¿”å›åç»§ç»“ç‚¹çš„æŒ‡é’ˆ
template <class T>
Node<T> *Node<T>::nextNode() {
    return next;
}
//è¿”å›åç»§ç»“ç‚¹çš„æŒ‡é’ˆ
template <class T>
const Node<T> *Node<T>::nextNode() const {
    return next;
} 
//åœ¨å½“å‰ç»“ç‚¹ä¹‹åæ’å…¥ä¸€ä¸ªç»“ç‚¹p 
template <class T>
void Node<T>::insertAfter(Node<T> *p) {
    p->next = next; //pç»“ç‚¹æŒ‡é’ˆåŸŸæŒ‡å‘å½“å‰ç»“ç‚¹çš„åç»§ç»“ç‚¹
    next = p;    //å½“å‰ç»“ç‚¹çš„æŒ‡é’ˆåŸŸæŒ‡å‘p 
}
//åˆ é™¤å½“å‰ç»“ç‚¹çš„åç»§ç»“ç‚¹ï¼Œå¹¶è¿”å›å…¶åœ°å€
template <class T> Node<T> *Node<T>::deleteAfter() {
    Node<T> *tempPtr = next;//å°†æ¬²åˆ é™¤çš„ç»“ç‚¹åœ°å€å­˜å‚¨åˆ°tempPträ¸­
    if (next == 0)  //å¦‚æœå½“å‰ç»“ç‚¹æ²¡æœ‰åç»§ç»“ç‚¹ï¼Œåˆ™è¿”å›ç©ºæŒ‡é’ˆ
        return 0;
    next = tempPtr->next;//ä½¿å½“å‰ç»“ç‚¹çš„æŒ‡é’ˆåŸŸæŒ‡å‘tempPtrçš„åç»§ç»“ç‚¹
    return tempPtr;         //è¿”å›è¢«åˆ é™¤çš„ç»“ç‚¹çš„åœ°å€
}
#endif //NODE_H
```


### é“¾è¡¨ç±»æ¨¡æ¿

**é“¾è¡¨çš„åŸºæœ¬æ“ä½œ**

* ç”Ÿæˆé“¾è¡¨

* æ’å…¥ç»“ç‚¹

* æŸ¥æ‰¾ç»“ç‚¹

* åˆ é™¤ç»“ç‚¹

* éå†é“¾è¡¨

* æ¸…ç©ºé“¾è¡¨

**ä¾‹9-6 é“¾è¡¨ç±»æ¨¡æ¿**

```
//LinkedList.h
#ifndef LINKEDLIST_H
#define LINKEDLIST_H
#include "Node.h"

template <class T>
class LinkedList {
private:
    //æ•°æ®æˆå‘˜ï¼š
    Node<T> *front, *rear;  //è¡¨å¤´å’Œè¡¨å°¾æŒ‡é’ˆ
    Node<T> *prevPtr, *currPtr;   //è®°å½•è¡¨å½“å‰éå†ä½ç½®çš„æŒ‡é’ˆï¼Œç”±æ’å…¥å’Œåˆ é™¤æ“ä½œæ›´æ–°
    int size;   //è¡¨ä¸­çš„å…ƒç´ ä¸ªæ•°
    int position;   //å½“å‰å…ƒç´ åœ¨è¡¨ä¸­çš„ä½ç½®åºå·ã€‚ç”±å‡½æ•°resetä½¿ç”¨

    //å‡½æ•°æˆå‘˜ï¼š
    //ç”Ÿæˆæ–°ç»“ç‚¹ï¼Œæ•°æ®åŸŸä¸ºitemï¼ŒæŒ‡é’ˆåŸŸä¸ºptrNext
    Node<T> *newNode(const T &item,Node<T> *ptrNext=NULL);

    //é‡Šæ”¾ç»“ç‚¹
    void freeNode(Node<T> *p);

    //å°†é“¾è¡¨L æ‹·è´åˆ°å½“å‰è¡¨ï¼ˆå‡è®¾å½“å‰è¡¨ä¸ºç©ºï¼‰ã€‚
    //è¢«æ‹·è´æ„é€ å‡½æ•°ã€operator = è°ƒç”¨
    void copy(const LinkedList<T>& L);

public:
    LinkedList();   //æ„é€ å‡½æ•°
    LinkedList(const LinkedList<T> &L);  //æ‹·è´æ„é€ å‡½æ•°
    ~LinkedList();  //ææ„å‡½æ•°
    LinkedList<T> & operator = (const LinkedList<T> &L); //é‡è½½èµ‹å€¼è¿ç®—ç¬¦

    int getSize() const;    //è¿”å›é“¾è¡¨ä¸­å…ƒç´ ä¸ªæ•°
    bool isEmpty() const;   //é“¾è¡¨æ˜¯å¦ä¸ºç©º

    void reset(int pos = 0);//åˆå§‹åŒ–æ¸¸æ ‡çš„ä½ç½®
    void next();    //ä½¿æ¸¸æ ‡ç§»åŠ¨åˆ°ä¸‹ä¸€ä¸ªç»“ç‚¹
    bool endOfList() const; //æ¸¸æ ‡æ˜¯å¦åˆ°äº†é“¾å°¾
    int currentPosition() const;    //è¿”å›æ¸¸æ ‡å½“å‰çš„ä½ç½®

    void insertFront(const T &item);    //åœ¨è¡¨å¤´æ’å…¥ç»“ç‚¹
    void insertRear(const T &item);     //åœ¨è¡¨å°¾æ·»åŠ ç»“ç‚¹
    void insertAt(const T &item);       //åœ¨å½“å‰ç»“ç‚¹ä¹‹å‰æ’å…¥ç»“ç‚¹
    void insertAfter(const T &item);    //åœ¨å½“å‰ç»“ç‚¹ä¹‹åæ’å…¥ç»“ç‚¹

    T deleteFront();    //åˆ é™¤å¤´ç»“ç‚¹
    void deleteCurrent();   //åˆ é™¤å½“å‰ç»“ç‚¹

    T& data();              //è¿”å›å¯¹å½“å‰ç»“ç‚¹æˆå‘˜æ•°æ®çš„å¼•ç”¨
    const T& data() const;   //è¿”å›å¯¹å½“å‰ç»“ç‚¹æˆå‘˜æ•°æ®çš„å¸¸å¼•ç”¨

    //æ¸…ç©ºé“¾è¡¨ï¼šé‡Šæ”¾æ‰€æœ‰ç»“ç‚¹çš„å†…å­˜ç©ºé—´ã€‚è¢«ææ„å‡½æ•°ã€operator= è°ƒç”¨
    void clear();
};

template <class T> //ç”Ÿæˆæ–°ç»“ç‚¹
Node<T> *LinkedList<T>::newNode(const T& item, Node<T>* ptrNext)
{
    Node<T> *p;
    p = new Node<T>(item, ptrNext);
    if (p == NULL)
    {
        cout << "Memory allocation failure!\n";
        exit(1);
    }
    return p;
}

template <class T>
void LinkedList<T>::freeNode(Node<T> *p) //é‡Šæ”¾ç»“ç‚¹
{
    delete p;
}

template <class T>
void LinkedList<T>::copy(const LinkedList<T>& L) //é“¾è¡¨å¤åˆ¶å‡½æ•°
{
    Node<T> *p = L.front;   //Pç”¨æ¥éå†L 
    int pos;
    while (p != NULL)   //å°†Lä¸­çš„æ¯ä¸€ä¸ªå…ƒç´ æ’å…¥åˆ°å½“å‰é“¾è¡¨æœ€å
    {
        insertRear(p->data);
        p = p->nextNode();
    }
    if (position == -1) //å¦‚æœé“¾è¡¨ç©º,è¿”å›
        return;
    //åœ¨æ–°é“¾è¡¨ä¸­é‡æ–°è®¾ç½®prevPtrå’ŒcurrPtr
    prevPtr = NULL;
    currPtr = front;
    for (pos = 0; pos != position; pos++)
    {
        prevPtr = currPtr;
        currPtr = currPtr->nextNode();
    }
}

template <class T>  //æ„é€ ä¸€ä¸ªæ–°é“¾è¡¨ï¼Œå°†æœ‰å…³æŒ‡é’ˆè®¾ç½®ä¸ºç©ºï¼Œsizeä¸º0ï¼Œpositionä¸º-1
LinkedList<T>::LinkedList() : front(NULL), rear(NULL),
prevPtr(NULL), currPtr(NULL), size(0), position(-1)
{}

template <class T>
LinkedList<T>::LinkedList(const LinkedList<T>& L)  //æ‹·è´æ„é€ å‡½æ•°
{
    front = rear = NULL;
    prevPtr = currPtr = NULL;
    size = 0;
    position = -1;
    copy(L);
}

template <class T>
LinkedList<T>::~LinkedList()    //ææ„å‡½æ•°
{
    clear();
}

template <class T>
LinkedList<T>& LinkedList<T>::operator=(const LinkedList<T>& L)//é‡è½½"="
{
    if (this == &L) // ä¸èƒ½å°†é“¾è¡¨èµ‹å€¼ç»™å®ƒè‡ªèº«
        return *this;
    clear();
    copy(L);
    return *this;
}

template <class T>
int LinkedList<T>::getSize() const  //è¿”å›é“¾è¡¨å¤§å°çš„å‡½æ•°
{
    return size;
}

template <class T>
bool LinkedList<T>::isEmpty() const //åˆ¤æ–­é“¾è¡¨ä¸ºç©ºå¦
{
    return size == 0;
}

template <class T>
void LinkedList<T>::reset(int pos)  //å°†é“¾è¡¨å½“å‰ä½ç½®è®¾ç½®ä¸ºpos 
{
    int startPos;
    if (front == NULL)  // å¦‚æœé“¾è¡¨ä¸ºç©ºï¼Œè¿”å›
        return;
    if (pos < 0 || pos > size - 1)  // å¦‚æœæŒ‡å®šä½ç½®ä¸åˆæ³•ï¼Œä¸­æ­¢ç¨‹åº
    {
        std::cerr << "Reset: Invalid list position: " << pos << endl;
        return;
    }
    // è®¾ç½®ä¸éå†é“¾è¡¨æœ‰å…³çš„æˆå‘˜
    if (pos == 0)   // å¦‚æœposä¸º0ï¼Œå°†æŒ‡é’ˆé‡æ–°è®¾ç½®åˆ°è¡¨å¤´
    {
        prevPtr = NULL;
        currPtr = front;
        position = 0;
    }
    else    // é‡æ–°è®¾ç½® currPtr, prevPtr, å’Œ position 
    {
        currPtr = front->nextNode();
        prevPtr = front;
        startPos = 1;
        for (position = startPos; position != pos; position++)
        {
            prevPtr = currPtr;
            currPtr = currPtr->nextNode();
        }
    }
}

template <class T>
void LinkedList<T>::next()  //å°†prevPtrå’ŒcurrPtrå‘å‰ç§»åŠ¨ä¸€ä¸ªç»“ç‚¹
{
    if (currPtr != NULL)
    {
        prevPtr = currPtr;
        currPtr = currPtr->nextNode();
        position++;
    }
}

template <class T>
bool LinkedList<T>::endOfList() const   // åˆ¤æ–­æ˜¯å¦å·²è¾¾è¡¨å°¾
{
    return currPtr == NULL;
}

template <class T>
int LinkedList<T>::currentPosition() const  // è¿”å›å½“å‰ç»“ç‚¹çš„ä½ç½®
{
    return position;
}

template <class T>
void LinkedList<T>::insertFront(const T& item)   // å°†itemæ’å…¥åœ¨è¡¨å¤´
{
    if (front != NULL)  // å¦‚æœé“¾è¡¨ä¸ç©ºåˆ™è°ƒç”¨Reset 
        reset();
    insertAt(item); // åœ¨è¡¨å¤´æ’å…¥
}

template <class T>
void LinkedList<T>::insertRear(const T& item)   // åœ¨è¡¨å°¾æ’å…¥ç»“ç‚¹
{
    Node<T> *nNode;
    prevPtr = rear;
    nNode = newNode(item);  // åˆ›å»ºæ–°ç»“ç‚¹
    if (rear == NULL)   // å¦‚æœè¡¨ç©ºåˆ™æ’å…¥åœ¨è¡¨å¤´
        front = rear = nNode;
    else
    {
        rear->insertAfter(nNode);
        rear = nNode;
    }
    currPtr = rear;
    position = size;
    size++;
}

template <class T>
void LinkedList<T>::insertAt(const T& item) // å°†itemæ’å…¥åœ¨é“¾è¡¨å½“å‰ä½ç½®
{
    Node<T> *nNode;
    if (prevPtr == NULL)    // æ’å…¥åœ¨é“¾è¡¨å¤´ï¼ŒåŒ…æ‹¬å°†ç»“ç‚¹æ’å…¥åˆ°ç©ºè¡¨ä¸­
    {
        nNode = newNode(item, front);
        front = nNode;
    }
    else    // æ’å…¥åˆ°é“¾è¡¨ä¹‹ä¸­. å°†ç»“ç‚¹ç½®äºprevPträ¹‹å
    {
        nNode = newNode(item);
        prevPtr->insertAfter(nNode);
    }
    if (prevPtr == rear)    //æ­£åœ¨å‘ç©ºè¡¨ä¸­æ’å…¥ï¼Œæˆ–è€…æ˜¯æ’å…¥åˆ°éç©ºè¡¨çš„è¡¨å°¾
    {
        rear = nNode;   //æ›´æ–°rear 
        position = size;    //æ›´æ–°position 
    }
    currPtr = nNode;    //æ›´æ–°currPtr
    size++; //ä½¿sizeå¢å€¼
}

template <class T>
void LinkedList<T>::insertAfter(const T& item)  // å°†item æ’å…¥åˆ°é“¾è¡¨å½“å‰ä½ç½®ä¹‹å
{
    Node<T> *p;
    p = newNode(item);
    if (front == NULL)   // å‘ç©ºè¡¨ä¸­æ’å…¥
    {
        front = currPtr = rear = p;
        position = 0;
    }
    else    // æ’å…¥åˆ°æœ€åä¸€ä¸ªç»“ç‚¹ä¹‹å
    {
        if (currPtr == NULL)
            currPtr = prevPtr;
        currPtr->insertAfter(p);
        if (currPtr == rear)
        {
            rear = p;
            position = size;
        }
        else
            position++;
        prevPtr = currPtr;
        currPtr = p;
    }
    size++;              // ä½¿é“¾è¡¨é•¿åº¦å¢å€¼
}

template <class T>
T LinkedList<T>::deleteFront()  // åˆ é™¤è¡¨å¤´ç»“ç‚¹
{
    T item;
    reset();
    if (front == NULL)
    {
        cerr << "Invalid deletion!" << endl;
        exit(1);
    }
    item = currPtr->data;
    deleteCurrent();
    return item;
}

template <class T>
void LinkedList<T>::deleteCurrent() // åˆ é™¤é“¾è¡¨å½“å‰ä½ç½®çš„ç»“ç‚¹
{
    Node<T> *p;
    if (currPtr == NULL)    // å¦‚æœè¡¨ç©ºæˆ–è¾¾åˆ°è¡¨å°¾åˆ™å‡ºé”™
    {
        cerr << "Invalid deletion!" << endl;
        exit(1);
    }
    if (prevPtr == NULL)    // åˆ é™¤å°†å‘ç”Ÿåœ¨è¡¨å¤´æˆ–é“¾è¡¨ä¹‹ä¸­
    {
        p = front;  // ä¿å­˜å¤´ç»“ç‚¹åœ°å€
        front = front->nextNode();  //å°†å…¶ä»é“¾è¡¨ä¸­åˆ†ç¦»
    }
    else    //åˆ†ç¦»prevPträ¹‹åçš„ä¸€ä¸ªå†…éƒ¨ç»“ç‚¹ï¼Œä¿å­˜å…¶åœ°å€
        p = prevPtr->deleteAfter();

    if (p == rear)  // å¦‚æœè¡¨å°¾ç»“ç‚¹è¢«åˆ é™¤
    {
        rear = prevPtr; //æ–°çš„è¡¨å°¾æ˜¯prevPtr 
        position--; //positionè‡ªå‡
    }
    currPtr = p->nextNode();    // ä½¿currPtrè¶Šè¿‡è¢«åˆ é™¤çš„ç»“ç‚¹
    freeNode(p);    // é‡Šæ”¾ç»“ç‚¹ï¼Œå¹¶
    size--; //ä½¿é“¾è¡¨é•¿åº¦è‡ªå‡
}

template <class T>
T& LinkedList<T>::data()    //è¿”å›ä¸€ä¸ªå½“å‰ç»“ç‚¹æ•°å€¼çš„å¼•ç”¨
{
    if (size == 0 || currPtr == NULL)   // å¦‚æœé“¾è¡¨ä¸ºç©ºæˆ–å·²ç»å®Œæˆéå†åˆ™å‡ºé”™
    {
        cerr << "Data: invalid reference!" << endl;
        exit(1);
    }
    return currPtr->data;
}

template <class T>
void LinkedList<T>::clear() //æ¸…ç©ºé“¾è¡¨
{
    Node<T> *currPosition, *nextPosition;
    currPosition = front;
    while (currPosition != NULL)
    {
        nextPosition = currPosition->nextNode(); //å–å¾—ä¸‹ä¸€ç»“ç‚¹çš„åœ°å€
        freeNode(currPosition); //åˆ é™¤å½“å‰ç»“ç‚¹
        currPosition = nextPosition;    //å½“å‰æŒ‡é’ˆç§»åŠ¨åˆ°ä¸‹ä¸€ç»“ç‚¹
    }
    front = rear = NULL;
    prevPtr = currPtr = NULL;
    size = 0;
    position = -1;
}
#endif  //LINKEDLIST_H

```

## 1.5 æ ˆ

### æ ˆç±»æ¨¡æ¿
**æ ˆç±»**

æ ˆæ˜¯åªèƒ½ä»ä¸€ç«¯è®¿é—®çš„çº¿æ€§ç¾¤ä½“ï¼Œå¯ä»¥è®¿é—®çš„è¿™ä¸€ç«¯ç§°**æ ˆé¡¶**ï¼Œå¦ä¸€ç«¯ç§°**æ ˆåº•**ã€‚æ ˆæ˜¯ä¸€ç§**åè¿›å…ˆå‡º**çš„æ•°æ®ç»“æ„ã€‚

**æ ˆç¤ºæ„å›¾**

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/%E6%A0%88%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

**æ ˆçš„åº”ç”¨ä¸¾ä¾‹â€”â€”è¡¨è¾¾å¼å¤„ç†**

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/%E6%A0%88%E5%BA%94%E7%94%A8%E4%B8%BE%E4%BE%8B_%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%84%E7%90%86.png)

**æ ˆçš„åŸºæœ¬çŠ¶æ€**
* æ ˆç©º

* æ ˆæ»¡

* ä¸€èˆ¬çŠ¶æ€

**æ ˆç©º**

* æ ˆä¸­æ²¡æœ‰å…ƒç´ ï¼ˆä»¥æ•°ç»„å®¹çº³çš„æ ˆä¸ºä¾‹ï¼‰

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/%E6%A0%88%E7%A9%BA.png)

**æ ˆæ»¡**

* æ ˆä¸­å…ƒç´ ä¸ªæ•°è¾¾åˆ°ä¸Šé™ï¼ˆä»¥æ•°ç»„å®¹çº³çš„æ ˆä¸ºä¾‹ï¼‰

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/%E6%A0%88%E6%BB%A1.png)

**ä¸€èˆ¬çŠ¶æ€**

* æ ˆä¸­æœ‰å…ƒç´ ï¼Œä½†æœªè¾¾åˆ°æ ˆæ»¡çŠ¶æ€ï¼ˆä»¥æ•°ç»„å®¹çº³çš„æ ˆä¸ºä¾‹ï¼‰

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/%E6%A0%88%E4%B8%80%E8%88%AC%E7%8A%B6%E6%80%81.png)

**æ ˆçš„åŸºæœ¬æ“ä½œ**

* åˆå§‹åŒ–

* å…¥æ ˆ

* å‡ºæ ˆ

* æ¸…ç©ºæ ˆ

* è®¿é—®æ ˆé¡¶å…ƒç´ 

* æ£€æµ‹æ ˆçš„çŠ¶æ€ï¼ˆæ»¡ã€ç©ºï¼‰

**ä¾‹9-8 æ ˆç±»æ¨¡æ¿**
```
//Stack.h
#ifndef STACK_H
#define STACK_H
#include <cassert> 
template <class T, int SIZE = 50>
class Stack {
private:
    T list[SIZE];
    int top;
public:
    Stack();
    void push(const T &item);
    T pop();
    void clear();
    const T &peek() const;
    bool isEmpty() const;
    bool isFull() const;
};

//æ¨¡æ¿çš„å®ç°
template <class T, int SIZE>
Stack<T, SIZE>::Stack() : top(-1) { }   
template <class T, int SIZE>
void Stack<T, SIZE>::push(const T &item) {  
    assert(!isFull());  
    list[++top] = item; 
}
template <class T, int SIZE>
T Stack<T, SIZE>::pop() {   
    assert(!isEmpty()); 
    return list[top--]; 
}
template <class T, int SIZE>
const T &Stack<T, SIZE>::peek() const {
    assert(!isEmpty()); 
    return list[top];   //è¿”å›æ ˆé¡¶å…ƒç´ 
}
template <class T, int SIZE>
bool Stack<T, SIZE>::isEmpty() const {
    return top == -1;
}
template <class T, int SIZE>
bool Stack<T, SIZE>::isFull() const {   
    return top == SIZE - 1;
}

template <class T, int SIZE>
void Stack<T, SIZE>::clear() {  
    top = -1;
}

#endif  //STACK_H
```

### ä¾‹9-9 æ ˆçš„åº”ç”¨


**ä¾‹9-9 ä¸€ä¸ªç®€å•çš„æ•´æ•°è®¡ç®—å™¨**

å®ç°ä¸€ä¸ªç®€å•çš„æ•´æ•°è®¡ç®—å™¨ï¼Œèƒ½å¤Ÿè¿›è¡ŒåŠ ã€å‡ã€ä¹˜ã€é™¤å’Œä¹˜æ–¹è¿ç®—ã€‚ä½¿ç”¨æ—¶ç®—å¼é‡‡ç”¨åç¼€è¾“å…¥æ³•ï¼Œæ¯ä¸ªæ“ä½œæ•°ã€æ“ä½œç¬¦ä¹‹é—´éƒ½ä»¥ç©ºç™½ç¬¦åˆ†éš”ã€‚ä¾‹å¦‚ï¼Œè‹¥è¦è®¡ç®—"3+5"åˆ™è¾“å…¥"3 5 +"ã€‚ä¹˜æ–¹è¿ç®—ç¬¦ç”¨"^"è¡¨ç¤ºã€‚æ¯æ¬¡è¿ç®—åœ¨å‰æ¬¡ç»“æœåŸºç¡€ä¸Šè¿›è¡Œï¼Œè‹¥è¦å°†å‰æ¬¡è¿ç®—ç»“æœæ¸…é™¤ï¼Œå¯é”®å…¥"c"ã€‚å½“é”®å…¥"q"æ—¶ç¨‹åºç»“æŸã€‚
```
//Calculator.h
#ifndef CALCULATOR_H
#define CALCULATOR_H
#include "Stack.h"  // åŒ…å«æ ˆç±»æ¨¡æ¿å®šä¹‰æ–‡ä»¶

class Calculator {  //è®¡ç®—å™¨ç±»
private:
    Stack<double> s;    // æ“ä½œæ•°æ ˆ
    void enter(double num); //å°†æ“ä½œæ•°numå‹å…¥æ ˆ
    //è¿ç»­å°†ä¸¤ä¸ªæ“ä½œæ•°å¼¹å‡ºæ ˆï¼Œæ”¾åœ¨opnd1å’Œopnd2ä¸­
    bool getTwoOperands(double &opnd1, double &opnd2);
    void compute(char op);  //æ‰§è¡Œç”±æ“ä½œç¬¦opæŒ‡å®šçš„è¿ç®—
public:
    void run();     //è¿è¡Œè®¡ç®—å™¨ç¨‹åº
    void clear();   //æ¸…ç©ºæ“ä½œæ•°æ ˆ
};
#endif //CALCULATOR_H

//Calculator.cpp
#include "Calculator.h"
#include <iostream>
#include <sstream>
#include <cmath>
using namespace std;

//å·¥å…·å‡½æ•°ï¼Œç”¨äºå°†å­—ç¬¦ä¸²è½¬æ¢ä¸ºå®æ•°
inline double stringToDouble(const string &str) {
    istringstream stream(str);  //å­—ç¬¦ä¸²è¾“å…¥æµ
    double result;
    stream >> result;
    return result;
}

void Calculator::enter(double num) {    //å°†æ“ä½œæ•°numå‹å…¥æ ˆ
    s.push(num);
}

bool Calculator::getTwoOperands(double &opnd1, double &opnd2) {
    if (s.isEmpty()) {  //æ£€æŸ¥æ ˆæ˜¯å¦ç©º
        cerr << "Missing operand!" << endl;
        return false;
    }
    opnd1 = s.pop();    //å°†å³æ“ä½œæ•°å¼¹å‡ºæ ˆ
    if (s.isEmpty()) {  //æ£€æŸ¥æ ˆæ˜¯å¦ç©º
        cerr << "Missing operand!" << endl;
        return false;
    }
    opnd2 = s.pop();    //å°†å·¦æ“ä½œæ•°å¼¹å‡ºæ ˆ
    return true;
}

void Calculator::compute(char op) { //æ‰§è¡Œè¿ç®—
    double operand1, operand2;
    bool result = getTwoOperands(operand1, operand2);   
    if (result) {   //å¦‚æœæˆåŠŸï¼Œæ‰§è¡Œè¿ç®—å¹¶å°†è¿ç®—ç»“æœå‹å…¥æ ˆ
        switch(op) {
        case '+': s.push(operand2 + operand1); break;
        case '-': s.push(operand2 - operand1); break;
        case '*': s.push(operand2 * operand1); break;
        case '/': if (operand1 == 0) {    //æ£€æŸ¥é™¤æ•°æ˜¯å¦ä¸º0
                 cerr << "Divided by 0!" << endl;
                 s.clear();    //é™¤æ•°ä¸º0æ—¶æ¸…ç©ºæ ˆ
                      } else
                 s.push(operand2 / operand1);
                      break;
        case '^': s.push(pow(operand2, operand1)); break;
        default:  cerr << "Unrecognized operator!" << endl;
                      break;
        }
        cout << "= " << s.peek() << " ";    //è¾“å‡ºæœ¬æ¬¡è¿ç®—ç»“æœ 
    } else
        s.clear();  //æ“ä½œæ•°ä¸å¤Ÿï¼Œæ¸…ç©ºæ ˆ
}

void Calculator::run() { //è¯»å…¥å¹¶å¤„ç†åç¼€è¡¨è¾¾å¼
    string str;
    while (cin >> str, str != "q") {
        switch(str[0]) {
        case 'c': s.clear(); break;
        case '-': //é‡'-'éœ€åˆ¤æ–­æ˜¯å‡å·è¿˜æ˜¯è´Ÿå·
            if (str.size() > 1)
                enter(stringToDouble(str)); 
            else
                compute(str[0]);    
            break;
        case '+':   //é‡åˆ°å…¶å®ƒæ“ä½œç¬¦æ—¶
        case '*':
        case '/':
        case '^':
            compute(str[0]);   break;
        default: //è‹¥è¯»å…¥çš„æ˜¯æ“ä½œæ•°ï¼Œè½¬æ¢ä¸ºæ•´å‹åå‹å…¥æ ˆ
            enter(stringToDouble(str)); break;
        }
    }
}
void Calculator::clear() {  //æ¸…ç©ºæ“ä½œæ•°æ ˆ
    s.clear(); 
}

//9_9.cpp
#include "Calculator.h"

int main() {
    Calculator c;
    c.run();
    return 0;
}

```
## 1.6 é˜Ÿåˆ—

### é˜Ÿåˆ—ç±»æ¨¡æ¿
é˜Ÿåˆ—æ˜¯åªèƒ½å‘ä¸€ç«¯æ·»åŠ å…ƒç´ ï¼Œä»å¦ä¸€ç«¯åˆ é™¤å…ƒç´ çš„çº¿æ€§ç¾¤ä½“

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/%E9%98%9F%E5%88%97%E7%B1%BB%E6%A8%A1%E6%9D%BF.png)

**é˜Ÿåˆ—çš„åŸºæœ¬çŠ¶æ€**

* é˜Ÿç©º

* é˜Ÿæ»¡

* ä¸€èˆ¬çŠ¶æ€

**é˜Ÿç©º**

* é˜Ÿåˆ—ä¸­æ²¡æœ‰å…ƒç´ ï¼ˆä»¥æ•°ç»„å®¹çº³çš„é˜Ÿåˆ—ä¸ºä¾‹ï¼‰

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/%E9%98%9F%E7%A9%BA.png)

**é˜Ÿæ»¡**

* é˜Ÿåˆ—ä¸­å…ƒç´ ä¸ªæ•°è¾¾åˆ°ä¸Šé™ï¼ˆä»¥æ•°ç»„å®¹çº³çš„é˜Ÿåˆ—ä¸ºä¾‹ï¼‰

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/%E9%98%9F%E6%BB%A1.png)

**ä¸€èˆ¬çŠ¶æ€**

* é˜Ÿåˆ—ä¸­æœ‰å…ƒç´ ï¼Œä½†æœªè¾¾åˆ°é˜Ÿæ»¡çŠ¶æ€ï¼ˆä»¥æ•°ç»„å®¹çº³çš„é˜Ÿåˆ—ä¸ºä¾‹ï¼‰

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/%E9%98%9F%E4%B8%80%E8%88%AC%E7%8A%B6%E6%80%81.png)

**å¾ªç¯é˜Ÿåˆ—**

* åœ¨æƒ³è±¡ä¸­å°†æ•°ç»„å¼¯æ›²æˆç¯å½¢ï¼Œå…ƒç´ å‡ºé˜Ÿæ—¶ï¼Œåç»§å…ƒç´ ä¸ç§»åŠ¨ï¼Œæ¯å½“é˜Ÿå°¾è¾¾åˆ°æ•°ç»„æœ€åä¸€ä¸ªå…ƒç´ æ—¶ï¼Œä¾¿å†å›åˆ°æ•°ç»„å¼€å¤´ã€‚

![](https://github.com/Mozart482/CS-Notes/blob/main/C%2B%2B%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/images/%E9%98%9F%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.png)

**ä¾‹9-10 é˜Ÿåˆ—ç±»æ¨¡æ¿**
```
//Queue.h
#ifndef QUEUE_H
#define QUEUE_H
#include <cassert>
//ç±»æ¨¡æ¿çš„å®šä¹‰
template <class T, int SIZE = 50>
class Queue {
private:
    int front, rear, count; //é˜Ÿå¤´æŒ‡é’ˆã€é˜Ÿå°¾æŒ‡é’ˆã€å…ƒç´ ä¸ªæ•°
    T list[SIZE];   //é˜Ÿåˆ—å…ƒç´ æ•°ç»„
public:
    Queue();          //æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–é˜Ÿå¤´æŒ‡é’ˆã€é˜Ÿå°¾æŒ‡é’ˆã€å…ƒç´ ä¸ªæ•°
    void insert(const T &item); //æ–°å…ƒç´ å…¥é˜Ÿ
    T remove(); //å…ƒç´ å‡ºé˜Ÿ
    void clear();   //æ¸…ç©ºé˜Ÿåˆ—
    const T &getFront() const;  //è®¿é—®é˜Ÿé¦–å…ƒç´ 
    //æµ‹è¯•é˜Ÿåˆ—çŠ¶æ€
    int getLength() const;//æ±‚é˜Ÿåˆ—é•¿åº¦
    bool isEmpty() const;//åˆ¤æ–­é˜Ÿåˆ—ç©ºå¦
    bool isFull() const;//åˆ¤æ–­é˜Ÿåˆ—æ»¡å¦
};
//æ„é€ å‡½æ•°ï¼Œåˆå§‹åŒ–é˜Ÿå¤´æŒ‡é’ˆã€é˜Ÿå°¾æŒ‡é’ˆã€å…ƒç´ ä¸ªæ•°
template <class T, int SIZE>
Queue<T, SIZE>::Queue() : front(0), rear(0), count(0) { }

template <class T, int SIZE>
void Queue<T, SIZE>::insert (const T& item) {//å‘é˜Ÿå°¾æ’å…¥å…ƒç´ 
    assert(count != SIZE);
    count++;    //å…ƒç´ ä¸ªæ•°å¢1
    list[rear] = item;  //å‘é˜Ÿå°¾æ’å…¥å…ƒç´ 
    rear = (rear + 1) % SIZE;   //é˜Ÿå°¾æŒ‡é’ˆå¢1ï¼Œç”¨å–ä½™è¿ç®—å®ç°å¾ªç¯é˜Ÿåˆ—
}
template <class T, int SIZE> T Queue<T, SIZE>::remove() {   
    assert(count != 0);
    int temp = front;   //è®°å½•ä¸‹åŸå…ˆçš„é˜Ÿé¦–æŒ‡é’ˆ
    count--;        //å…ƒç´ ä¸ªæ•°è‡ªå‡
    front = (front + 1) % SIZE;//é˜Ÿé¦–æŒ‡é’ˆå¢1ã€‚å–ä½™ä»¥å®ç°å¾ªç¯é˜Ÿåˆ—
    return list[temp];  //è¿”å›é¦–å…ƒç´ å€¼
}
template <class T, int SIZE>
const T &Queue<T, SIZE>::getFront() const { 
    return list[front];
}
template <class T, int SIZE>
int Queue<T, SIZE>::getLength() const { //è¿”å›é˜Ÿåˆ—å…ƒç´ ä¸ªæ•°
    return count;
}

template <class T, int SIZE>
bool Queue<T, SIZE>::isEmpty() const {  //æµ‹è¯•é˜Ÿç©ºå¦
    return count == 0;
}
template <class T, int SIZE>
bool Queue<T, SIZE>::isFull() const {   //æµ‹è¯•é˜Ÿæ»¡å¦
    return count == SIZE;
}
template <class T, int SIZE>
void Queue<T, SIZE>::clear() {  //æ¸…ç©ºé˜Ÿåˆ—
    count = 0;
    front = 0; 
    rear = 0; 
}
#endif  //QUEUE_H
```

## 1.7 æ’åº


